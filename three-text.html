<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Zoom → Summary to Detail (Three.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background: radial-gradient(#0e0f14, #05060a); }
    #app { width:100%; height:100%; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; padding: 8px 10px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:#cfd3ff; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px; backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Scroll / pinch to zoom. Drag to orbit. Text dissolves: sentence → paragraph → three paragraphs.</div>

    <script type="importmap">
    {
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
    }
    </script>
  <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ---------- Content you can change ----------
    const TEXT_LEVELS = {
      sentence: `Machines learn; humans teach and revise—learning is a dance between both.`,
      paragraph: `Learning condenses experience. A summary sketches the arc: we sample data, infer patterns, and update when predictions fail. Brevity compresses; readers decompress with prior knowledge.`,
      detail: [
        `Human learning entwines perception, memory, language, and culture. A child generalizes from sparse examples because the world is scaffolded by tools, caregivers, and norms.`,
        `Machine learning trades that social scaffolding for dense examples and objectives. Models interpolate across data, guided by losses that approximate our aims.`,
        `Pedagogy bridges them: we choose representations, prompts, curricula, and evaluations so compression (summaries, models) can safely expand into meaning.`
      ]
    };

    // Blend ranges (camera distance thresholds)
    const BLEND = { farOn:26, farOff:18, midOn:16, midOff:10, nearOn:9, nearOff:4 };

    // ---------- Boilerplate ----------
    const el = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(el.clientWidth, el.clientHeight);
    el.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, el.clientWidth/el.clientHeight, 0.1, 200);
    camera.position.set(0, 0.6, 28);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.minDistance = 3;
    controls.maxDistance = 80;
    controls.target.set(0, 0.6, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.9));

    // ---------- Helpers ----------
    const clamp = THREE.MathUtils.clamp;
    function smoothstep(a, b, x) {
      const t = clamp((x - a) / (b - a), 0, 1);
      return t * t * (3 - 2 * t);
    }
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function makeTextCanvas(text, { fontSize=28, maxWidth=900, lineHeight=1.3, padding=32, align='center' }={}) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const font = `${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
      ctx.font = font;

      // Wrap lines
      const words = text.split(/\s+/);
      const lines = [];
      let line = '';
      for (const w of words) {
        const test = line ? line+' '+w : w;
        if (ctx.measureText(test).width > maxWidth && line) { lines.push(line); line = w; }
        else line = test;
      }
      if (line) lines.push(line);

      const lh = Math.round(fontSize * lineHeight);
      const textWidth = Math.min(maxWidth, Math.max(...lines.map(t => ctx.measureText(t).width)));
      const textHeight = lines.length * lh;

      const scale = Math.min(2, devicePixelRatio || 1);
      canvas.width  = Math.ceil((textWidth  + padding*2) * scale);
      canvas.height = Math.ceil((textHeight + padding*2) * scale);
      ctx.setTransform(scale, 0, 0, scale, 0, 0);

      // Card background
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      roundRect(ctx, 0, 0, canvas.width/scale, canvas.height/scale, 16);
      ctx.fill();

      // Text
      ctx.font = font;
      ctx.textBaseline = 'top';
      ctx.fillStyle = 'rgba(230,235,255,0.94)';
      let y = padding;
      for (const L of lines) {
        const w = ctx.measureText(L).width;
        let x = padding;
        if (align === 'center') x = padding + (textWidth - w)/2;
        if (align === 'right')  x = padding + (textWidth - w);
        ctx.fillText(L, Math.round(x), Math.round(y));
        y += lh;
      }
      return canvas;
    }
    function makeTextCard(text, options={}) {
      const canvas = makeTextCanvas(text, options);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
      const geo = new THREE.PlaneGeometry(canvas.width/canvas.height * 1.5, 1.5);
      const mesh = new THREE.Mesh(geo, mat);
      const hWorld = 6;
      const aspect = canvas.width/canvas.height;
      mesh.scale.set(hWorld*aspect, hWorld, 1);
      return { mesh, material: mat };
    }

    // ---------- Build levels ----------
    const group = new THREE.Group(); scene.add(group);

    const L0 = makeTextCard(TEXT_LEVELS.sentence, { fontSize: 42, maxWidth: 900, lineHeight: 1.2 });
    L0.mesh.position.set(0, 1.0, 0); group.add(L0.mesh);

    const L1 = makeTextCard(TEXT_LEVELS.paragraph, { fontSize: 28, maxWidth: 1000, lineHeight: 1.35 });
    L1.mesh.position.set(0, 1.0, 0.02); group.add(L1.mesh);

    const L2 = makeTextCard(TEXT_LEVELS.detail.join('\n\n'), { fontSize: 26, maxWidth: 1100, lineHeight: 1.4, align: 'left' });
    L2.mesh.position.set(0, 1.0, 0.04); group.add(L2.mesh);

    // Floor cues
    const ring = new THREE.Mesh(new THREE.RingGeometry(3.6, 3.8, 128),
      new THREE.MeshBasicMaterial({ color: 0x5e68ff, transparent: true, opacity: 0.18, side: THREE.DoubleSide }));
    ring.rotation.x = -Math.PI/2; ring.position.y = -2.4; scene.add(ring);

    const floor = new THREE.Mesh(new THREE.CircleGeometry(8, 96),
      new THREE.MeshBasicMaterial({ color: 0x101218, transparent: true, opacity: 0.6 }));
    floor.rotation.x = -Math.PI/2; floor.position.y = -2.41; scene.add(floor);

    // ---------- Crossfade logic ----------
    function updateFades() {
      const d = camera.position.distanceTo(controls.target);

      const sentenceAlpha  = 1.0 - smoothstep(BLEND.farOff,  BLEND.farOn,  d);
      const paraIn         =       smoothstep(BLEND.farOff,  BLEND.midOn,  d);
      const paraOut        = 1.0 - smoothstep(BLEND.midOff,  BLEND.midOn,  d);
      const paragraphAlpha = Math.min(paraIn, paraOut);
      const detailAlpha    =       smoothstep(BLEND.nearOff, BLEND.nearOn, d);

      L0.material.opacity = sentenceAlpha;
      L1.material.opacity = paragraphAlpha;
      L2.material.opacity = detailAlpha;

      group.scale.setScalar(clamp(d/14, 0.75, 2.0));
      ring.material.opacity = 0.12 + 0.06 * Math.sin(performance.now()*0.0015);
    }

    function onResize() {
      const w = el.clientWidth, h = el.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
    }
    addEventListener('resize', onResize);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      updateFades();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
