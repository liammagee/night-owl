<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Part–Whole Visualizer • three.js (with transitions toggle)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e8f0ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; }
    #app { position: absolute; inset: 0; overflow: hidden; }
    canvas { display: block; }
    .ui { position: absolute; top: 12px; left: 12px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; background: rgba(12,16,22,.6); backdrop-filter: blur(6px); padding: 10px 12px; border-radius: 14px; box-shadow: 0 6px 30px rgba(0,0,0,.35); border: 1px solid #223042; }
    .ui button { appearance: none; border: 1px solid #2a3340; background: #111722; color: #cfe1ff; padding: 6px 10px; border-radius: 10px; font-weight: 600; letter-spacing: .2px; cursor: pointer; transition: transform .06s ease, background .2s ease, color .2s ease, border-color .2s ease; font-size: 12px; }
    .ui button:hover { background: #151e2b; }
    .ui button.active { border-color: #4aa8ff; color: #fff; box-shadow: 0 0 0 2px rgba(74,168,255,.25) inset; }
    .ui .sep { width: 1px; height: 24px; background: #2a3340; margin: 0 4px; }
    .slider { display:flex; align-items:center; gap:8px; }
    .slider input[type="range"]{ width: 140px; }
    .legend { position: absolute; right: 12px; top: 12px; background: rgba(12,16,22,.55); padding: 10px 12px; border-radius: 12px; border: 1px solid #2a3340; font-size: 12px; line-height: 1.35; color: #cde0ff; max-width: 320px; }
    .legend b { color: #fff; }
    .footer { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #a9b8d0; opacity: .75; text-align:center; }
    .status { position: absolute; right: 12px; bottom: 12px; background: rgba(10,18,28,.75); border: 1px solid #223042; padding: 8px 10px; border-radius: 10px; font-size: 12px; max-width: 420px; }
    .status.ok { border-color: #1f5f2a; color: #c9ffd6; }
    .status.warn { border-color: #7a5a1a; color: #ffe8b8; }
    .status.err { border-color: #6b2b2b; color: #ffd3d3; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="ui" id="ui">
    <button data-mode="circle" class="active">1) Circular Graph</button>
    <button data-mode="rings">2) Oriented Rings</button>
    <button data-mode="spiral">3) Spiral</button>
    <div class="sep"></div>
    <div class="slider">
      <label for="parts">Parts:</label>
      <input id="parts" type="range" min="2" max="12" value="5" />
      <span id="partsVal">5</span>
    </div>
    <div class="sep"></div>
    <button id="toggleAnim" class="active" title="Toggle view transitions">Animations: On</button>
    <button id="reset">Reset View</button>
    <button id="runTests" title="Run built-in smoke tests">Run Tests</button>
  </div>
  <div class="legend">
    <div><b>Whole</b>: central concept (cyan)</div>
    <div><b>Parts</b>: components (purple)</div>
    <div><b>Edges</b>: relations (soft glow)</div>
    <div style="margin-top:6px; opacity:.85">Loads via unpkg/jsDelivr (npm) with local fallback. If OrbitControls CDN fails, a minimal in-page controls shim is used.</div>
  </div>
  <div class="footer">Drag to orbit • Scroll to zoom • Shift+Drag to pan</div>
  <div class="status" id="status">Loading three.js…</div>

  <!-- Loader with reliable CDNs and local fallback -->
  <script>
    function injectScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous';
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error('Failed to load ' + src));
        document.head.appendChild(s);
      });
    }

    async function loadThreeAndControls() {
      const status = document.getElementById('status');
      function setStatus(msg, cls='ok') { status.textContent = msg; status.className = 'status ' + cls; }

      const threeURLs = [
        './three.core.min.js'
      ];
      const controlsURLs = [
        './OrbitControls.js'
      ];

      let ok = false;
      for (const url of threeURLs) {
        try { await injectScript(url); if (window.THREE) { ok = true; break; } } catch(e) {}
      }
      if (!ok) { setStatus('Error loading three.js. Check your network or provide local three.min.js.', 'err'); throw new Error('THREE failed'); }
      setStatus('three.js loaded ✓');

      ok = false;
      for (const url of controlsURLs) {
        try { await injectScript(url); if (THREE.OrbitControls) { ok = true; break; } if (window.OrbitControls && !THREE.OrbitControls) { THREE.OrbitControls = window.OrbitControls; ok = true; break; } } catch(e) {}
      }
      if (!ok) {
        // Minimal in-page OrbitControls shim
        class MinimalOrbitControls {
          constructor(camera, domElement) {
            this.object = camera; this.domElement = domElement; this.target = new THREE.Vector3();
            this.enableDamping = true; this.dampingFactor = 0.08;
            this.rotateSpeed = 0.0028; this.zoomSpeed = 1.0; this.panSpeed = 0.0025;
            this._spherical = new THREE.Spherical(); this._offset = new THREE.Vector3();
            this._state = 'none'; this._last = { x:0, y:0 };
            domElement.addEventListener('mousedown', this._onDown);
            domElement.addEventListener('mousemove', this._onMove);
            domElement.addEventListener('mouseup',   this._onUp);
            domElement.addEventListener('wheel',     this._onWheel, { passive: false });
            domElement.addEventListener('mouseleave',this._onUp);
          }
          _onDown = (e)=>{ this._state = e.shiftKey ? 'pan' : 'rot'; this._last.x=e.clientX; this._last.y=e.clientY; };
          _onMove = (e)=>{ if (this._state==='none') return; const dx=e.clientX-this._last.x, dy=e.clientY-this._last.y; this._last.x=e.clientX; this._last.y=e.clientY; if (this._state==='rot') this._rotate(dx,dy); else this._pan(dx,dy); };
          _onUp = ()=>{ this._state='none'; };
          _onWheel = (e)=>{ e.preventDefault(); const delta = (e.deltaY>0?1:-1) * this.zoomSpeed; this._zoom(delta); };
          _rotate(dx, dy){ this._offset.copy(this.object.position).sub(this.target); this._spherical.setFromVector3(this._offset); this._spherical.theta -= dx*this.rotateSpeed; this._spherical.phi -= dy*this.rotateSpeed; const EPS=1e-6; this._spherical.phi=Math.max(EPS, Math.min(Math.PI-EPS, this._spherical.phi)); this._offset.setFromSpherical(this._spherical); this.object.position.copy(this.target).add(this._offset); this.object.lookAt(this.target); }
          _zoom(delta){ const factor = Math.pow(0.95, delta*2); this.object.position.sub(this.target).multiplyScalar(factor).add(this.target); }
          _pan(dx, dy){ const dist=this.object.position.distanceTo(this.target); const panX=-dx*this.panSpeed*dist*(this.object.fov/60); const panY=dy*this.panSpeed*dist*(this.object.fov/60); const right=new THREE.Vector3(), up=new THREE.Vector3(0,1,0), f=new THREE.Vector3(); this.object.getWorldDirection(f); right.crossVectors(up,f).normalize(); const trueUp=new THREE.Vector3().crossVectors(f,right).normalize(); const delta=new THREE.Vector3().addScaledVector(right,panX).addScaledVector(trueUp,panY); this.object.position.add(delta); this.target.add(delta); }
          update(){}
        }
        THREE.OrbitControls = MinimalOrbitControls;
        setStatus('OrbitControls CDN failed; using minimal in-page controls.', 'warn');
      } else {
        setStatus('OrbitControls loaded ✓', 'ok');
      }
    }

    window.__loadThreePromise = loadThreeAndControls();
  </script>

  <!-- Main app -->
  <script>
  (async function() {
    const status = document.getElementById('status');
    const setStatus = (msg, cls='ok') => { status.textContent = msg; status.className = 'status ' + cls; };

    try { await window.__loadThreePromise; } catch (e) { setStatus('Fatal: three.js failed to load.', 'err'); return; }

    // ---------- Scene setup ----------
    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 40, 120);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 28);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x0b0f14, 1);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xaad7ff, 0x0b0f14, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(6, 12, 8);
    scene.add(dir);

    // Background stars
    const stars = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({ size: 0.02, color: 0x496d8f, transparent: true, opacity: 0.7 })
    );
    (function addStars() {
      const N = 1200, pos = new Float32Array(N * 3);
      for (let i = 0; i < N; i++) {
        const r = THREE.MathUtils.randFloat(60, 140);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
        pos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.cos(phi);
        pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
      }
      stars.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      scene.add(stars);
    })();

    // Materials & helpers (smaller nodes + labels)
    const wholeMat = new THREE.MeshStandardMaterial({ color: 0x4ad8ff, metalness: 0.2, roughness: 0.3, emissive: 0x062030, emissiveIntensity: 0.4, transparent: true, opacity: 1 });
    const partMat  = new THREE.MeshStandardMaterial({ color: 0x9a7cff, metalness: 0.15, roughness: 0.35, emissive: 0x120a2e, emissiveIntensity: 0.35, transparent: true, opacity: 1 });
    const edgeMat  = new THREE.LineBasicMaterial({ color: 0x7fb8ff, transparent: true, opacity: 0.65 });
    const ringMat  = new THREE.LineBasicMaterial({ color: 0x8aa4ff, transparent: true, opacity: 0.7 });

    const NODE = { wholeR: 0.6, partR: 0.4, glowWhole: 1.25, glowPart: 1.1 };

    function makeSphere(r, mat, kind='part', labelText=null) {
      const geo = new THREE.IcosahedronGeometry(r, 2);
      const mesh = new THREE.Mesh(geo, mat.clone());
      mesh.userData.kind = kind;
      if (labelText) {
        const label = makeLabel(labelText);
        label.position.set(0, r + 0.55, 0);
        mesh.add(label);
      }
      return mesh;
    }

    function makeGlow(mesh, color = 0x4ad8ff, size = 1.1) {
      const glowGeo = new THREE.SphereGeometry(size, 32, 32);
      const glowMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.08, blending: THREE.AdditiveBlending, depthWrite: false });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.scale.copy(mesh.scale).multiplyScalar(1.0);
      mesh.add(glow);
      return glow;
    }

    function makeLabel(text, color = '#e8f0ff') {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const fontSize = 48; // smaller
      ctx.font = `600 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      const pad = 24;
      const metrics = ctx.measureText(text);
      canvas.width = Math.max(48, Math.ceil(metrics.width + pad * 2));
      canvas.height = fontSize + pad * 2;
      const ctx2 = canvas.getContext('2d');
      ctx2.font = `600 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx2.fillStyle = 'rgba(12,16,22,0.6)';
      ctx2.strokeStyle = 'rgba(74,168,255,0.35)';
      ctx2.lineWidth = 5;
      const radius = 16;
      const w = canvas.width, h = canvas.height;
      ctx2.beginPath();
      ctx2.moveTo(radius, 0);
      ctx2.arcTo(w, 0, w, h, radius);
      ctx2.arcTo(w, h, 0, h, radius);
      ctx2.arcTo(0, h, 0, 0, radius);
      ctx2.arcTo(0, 0, w, 0, radius);
      ctx2.closePath();
      ctx2.fill();
      ctx2.stroke();
      ctx2.fillStyle = color;
      ctx2.textBaseline = 'middle';
      ctx2.fillText(text, pad, h/2 + 1);

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true, opacity: 0.9 });
      const sprite = new THREE.Sprite(spriteMat);
      const scale = 0.012; // smaller labels
      sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);
      return sprite;
    }

    // Groups for three views
    const gCircle = new THREE.Group();
    const gRings  = new THREE.Group();
    const gSpiral = new THREE.Group();
    scene.add(gCircle, gRings, gSpiral);

    // Parameters
    let PARTS = 5;

    // ---------- 1) Circular Graph (Whole at top) ----------
    function buildCircularGraph() {
      gCircle.clear();
      const radius = 8;

      // Circle outline
      const circlePts = new THREE.EllipseCurve(0,0, radius, radius).getPoints(128).map(p=>new THREE.Vector3(p.x, p.y, 0));
      const circle = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(circlePts), ringMat.clone());
      gCircle.add(circle);

      // Whole explicitly at top
      const whole = makeSphere(NODE.wholeR, wholeMat, 'whole', 'Whole');
      whole.position.set(0, radius, 0);
      makeGlow(whole, 0x4ad8ff, NODE.glowWhole);
      gCircle.add(whole);

      // Parts around remaining circumference (exclude top)
      // Use PARTS+1 slots around the perimeter; reserve the top slot for Whole
      // This guarantees no Part coincides with the Whole for any PARTS value
      for (let i = 0; i < PARTS; i++) {
        const step = (2 * Math.PI) / (PARTS + 1);
        const angle = -Math.PI/2 + (i + 1) * step; // skip the first slot at top
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        const part = makeSphere(NODE.partR, partMat, 'part', `Part ${i+1}`);
        part.position.set(x, y, 0);
        makeGlow(part, 0x9a7cff, NODE.glowPart);
        gCircle.add(part);
        gCircle.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([whole.position.clone(), part.position.clone()]), edgeMat.clone()));
      }
    }

    // ---------- 2) Oriented Rings (same Z axis orientation; opposite parts) ----------
    function buildRings() {
      gRings.clear();
      const R = 6.5; // ring radius
      const segments = 160;

      const whole = makeSphere(NODE.wholeR, wholeMat, 'whole', 'Whole');
      makeGlow(whole, 0x4ad8ff, NODE.glowWhole);
      whole.position.set(0, R, 0); // shared top point
      gRings.add(whole);

      for (let i = 0; i < PARTS; i++) {
        const tilt = (i / Math.max(1, PARTS-1)) * Math.PI * 0.9 - Math.PI * 0.45; // rotate around X only
        const pts = [];
        for (let j = 0; j < segments; j++) {
          const t = j / segments * Math.PI * 2;
          const p = new THREE.Vector3(R * Math.cos(t), 0, R * Math.sin(t));
          p.applyAxisAngle(new THREE.Vector3(1,0,0), tilt); // preserve Z orientation
          pts.push(p);
        }
        // Align highest point to Whole
        let idxMax = 0, maxY = -Infinity;
        for (let k = 0; k < pts.length; k++) { if (pts[k].y > maxY) { maxY = pts[k].y; idxMax = k; } }
        const offset = new THREE.Vector3().subVectors(whole.position, pts[idxMax]);
        for (let k = 0; k < pts.length; k++) pts[k].add(offset);
        const ring = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(pts), ringMat.clone());
        gRings.add(ring);

        // Choose the point exactly opposite idxMax around the ring to avoid coinciding
        const idxOpp = (idxMax + Math.floor(segments/2)) % segments;
        const partPos = pts[idxOpp];
        const part = makeSphere(NODE.partR, partMat, 'part', `Part ${i+1}`);
        part.position.copy(partPos);
        makeGlow(part, 0x9a7cff, NODE.glowPart);
        gRings.add(part);

        gRings.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([whole.position.clone(), part.position.clone()]), edgeMat.clone()));
      }
    }

    // ---------- 3) Spiral (one loop per part; central thread) ----------
    function buildSpiral() {
      gSpiral.clear();
      const whole = makeSphere(NODE.wholeR, wholeMat, 'whole', 'Whole');
      makeGlow(whole, 0x4ad8ff, NODE.glowWhole);
      whole.position.set(0, 0, 0);
      gSpiral.add(whole);

      const turns = Math.max(1, PARTS);
      const a = 0.5, b = 1.0, steps = 900;
      const pts = [];
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const theta = turns * Math.PI * 2 * t;
        const r = a + b * theta / (2*Math.PI);
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = 0.06 * theta; // rising spiral
        pts.push(new THREE.Vector3(x, y, z));
      }
      const spiral = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color: 0x89b8ff, transparent: true, opacity: 0.8 }));
      gSpiral.add(spiral);

      // Central thread (linear spine through expansion)
      const yMax = pts[pts.length-1].y;
      const threadGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, yMax, 0) ]);
      const thread = new THREE.Line(threadGeo, new THREE.LineDashedMaterial({ color: 0x4ad8ff, dashSize: 0.5, gapSize: 0.3, transparent: true, opacity: 0.9 }));
      thread.computeLineDistances();
      thread.userData.kind = 'thread';
      gSpiral.add(thread);

      // Place parts near the end of each loop; ensure none coincides with Whole
      for (let k = 1; k <= PARTS; k++) {
        const theta = (k - 0.2) * (2 * Math.PI); // slightly before each full loop to avoid exact origin alignment
        const r = a + b * theta / (2*Math.PI);
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const y = 0.06 * theta;
        const p = new THREE.Vector3(x, y, z);

        const part = makeSphere(NODE.partR + 0.02, partMat, 'part', `Part ${k}`);
        part.position.copy(p);
        makeGlow(part, 0x9a7cff, NODE.glowPart);
        gSpiral.add(part);
        gSpiral.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), p ]), edgeMat.clone()));
      }
    }

    function rebuildAll() { buildCircularGraph(); buildRings(); buildSpiral(); }
    rebuildAll();

    // ---------- Transitions between views (toggleable) ----------
    function setGroupOpacity(group, alpha) {
      group.traverse(obj => {
        if (obj.material) {
          const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
          mats.forEach(m => { if ('opacity' in m) { m.transparent = true; m.opacity = alpha; } });
        }
        if (obj.type === 'Sprite') { obj.material.transparent = true; obj.material.opacity = alpha; }
      });
    }

    let current = gCircle;
    setGroupOpacity(gCircle, 1); setGroupOpacity(gRings, 0); setGroupOpacity(gSpiral, 0);
    gCircle.visible = true; gRings.visible = true; gSpiral.visible = true;

    let animationsEnabled = true;
    const toggleBtn = document.getElementById('toggleAnim');
    toggleBtn.addEventListener('click', () => {
      animationsEnabled = !animationsEnabled;
      toggleBtn.classList.toggle('active', animationsEnabled);
      toggleBtn.textContent = 'Animations: ' + (animationsEnabled ? 'On' : 'Off');
    });

    function transitionTo(next) {
      if (current === next) return;
      // Compute camera framing for both groups and animate a dolly + target move
      const from = current, to = next;

      function computeFrame(group) {
        const box = new THREE.Box3().setFromObject(group);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const dist = maxDim * 1.6 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
        return { center, dist };
      }

      const camDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      const fromFrame = computeFrame(from);
      const toFrame   = computeFrame(to);
      const fromPos = camera.position.clone();
      const toPos   = toFrame.center.clone().add(camDir.clone().multiplyScalar(toFrame.dist));
      const fromTarget = controls.target.clone();
      const toTarget   = toFrame.center.clone();

      const duration = animationsEnabled ? 650 : 0; // ms
      if (!animationsEnabled) {
        setGroupOpacity(from, 0); setGroupOpacity(to, 1);
        from.scale.setScalar(0.98); to.scale.setScalar(1.0);
        camera.position.copy(toPos); controls.target.copy(toTarget); controls.update();
        current = next; return;
      }

      const start = performance.now();
      // initial scales for subtle reassembly feel
      const fromStartScale = 1.0, toStartScale = 0.92;
      from.scale.setScalar(fromStartScale);
      to.scale.setScalar(toStartScale);

      function tick(now) {
        const t = Math.min(1, (now - start) / duration);
        const ease = t<0.5 ? 2*t*t : -1+(4-2*t)*t; // easeInOutQuad

        // cross-fade
        setGroupOpacity(from, 1 - ease);
        setGroupOpacity(to, ease);

        // group scale (gives impression of nodes reassembling into place)
        const fromScale = fromStartScale * (1 - 0.06 * ease);
        const toScale   = toStartScale + (1.0 - toStartScale) * ease;
        from.scale.setScalar(fromScale);
        to.scale.setScalar(toScale);

        // camera dolly + target move
        camera.position.lerpVectors(fromPos, toPos, ease);
        controls.target.lerpVectors(fromTarget, toTarget, ease);
        controls.update();

        if (t < 1) requestAnimationFrame(tick); else {
          current = next;
        }
      }
      requestAnimationFrame(tick);
    }

    // ---------- UI interactions ----------
    const modeButtons = Array.from(document.querySelectorAll('.ui button[data-mode]'));
    let mode = 'circle';
    function setMode(m) {
      mode = m;
      modeButtons.forEach(b => b.classList.toggle('active', b.dataset.mode === m));
      const target = m === 'circle' ? gCircle : m === 'rings' ? gRings : gSpiral;
      frameCurrent(target);
      transitionTo(target);
    }
    modeButtons.forEach(btn => btn.addEventListener('click', () => setMode(btn.dataset.mode)));
    setMode('circle');

    const partsSlider = document.getElementById('parts');
    const partsVal = document.getElementById('partsVal');
    partsSlider.addEventListener('input', () => {
      PARTS = parseInt(partsSlider.value, 10);
      partsVal.textContent = PARTS;
      rebuildAll();
      setMode(mode);
    });

    document.getElementById('reset').addEventListener('click', () => {
      camera.position.set(0, 10, 28);
      controls.target.set(0, 0, 0);
      controls.update();
    });

    function frameCurrent(group) {
      const box = new THREE.Box3().setFromObject(group);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      controls.target.copy(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fitDist = maxDim * 1.6 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
      const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      camera.position.copy(center.clone().add(dir.multiplyScalar(fitDist)));
      controls.update();
    }

    // ---------- Animate ----------
    const clock = new THREE.Clock();
    function animate() {
      const t = clock.getElapsedTime();
      stars.rotation.y = t * 0.003; // subtle parallax only; keep views stable
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ---------- Smoke tests ----------
    function countKind(group, kind) { let n = 0; group.traverse(o=>{ if (o.userData && o.userData.kind===kind) n++; }); return n; }
    function runTests() {
      const results = []; const ok=(c,m)=>results.push({pass:!!c,msg:m});
      ok(!!window.THREE, 'THREE global present');
      ok(!!THREE.OrbitControls, 'OrbitControls available (CDN or shim)');
      ok(countKind(gCircle,'whole')===1 && countKind(gCircle,'part')===PARTS, 'Circle counts correct');
      ok(countKind(gRings,'whole')===1 && countKind(gRings,'part')===PARTS, 'Rings counts correct');
      ok(countKind(gSpiral,'whole')===1 && countKind(gSpiral,'part')===PARTS, 'Spiral counts correct');
      // Circle: Whole should be highest Y among nodes
      let maxY=-Infinity, wholeY=-Infinity; gCircle.traverse(o=>{ if (o.isMesh && o.userData){ if(o.userData.kind==='whole') wholeY=o.position.y; if(o.userData.kind==='part') maxY=Math.max(maxY,o.position.y); }});
      ok(wholeY>maxY, 'Circle: Whole at top (highest Y)');
      // Rings: distance Whole->Part approximately diameter (2R)
      let ringCheck=true; const R=6.5; gRings.children.forEach(obj=>{ if (obj.userData && obj.userData.kind==='part') { const w = gRings.children.find(o=>o.userData&&o.userData.kind==='whole'); if(w){ const d=w.position.distanceTo(obj.position); if (Math.abs(d-2*R)>0.6) ringCheck=false; } } });
      ok(ringCheck, 'Rings: Part opposite Whole (≈ diameter distance)');
      // Spiral: has central thread and none of the parts is at origin
      let hasThread=false, partAtOrigin=false; gSpiral.traverse(o=>{ if(o.userData&&o.userData.kind==='thread') hasThread=true; if(o.userData&&o.userData.kind==='part'){ if(o.position.length()<1e-3) partAtOrigin=true; } });
      ok(hasThread, 'Spiral: central thread exists');
      ok(!partAtOrigin, 'Spiral: no part coincides with Whole');
      console.table(results);
      return results;
    }
    document.getElementById('runTests').addEventListener('click', runTests);
    runTests();
  })();
  </script>
</body>
</html>
