<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://cdn.tailwindcss.com 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        font-src 'self' data:;
        img-src 'self' data:;
        connect-src 'self';
        worker-src 'self' blob:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hegel Pedagogy AI - Advanced Editor & Presentations</title>
    
    <!-- Styles -->
    <link rel="stylesheet" href="orchestrator/style.css">
    <style>
        /* Content view styles */
        .content-view {
            display: none !important;
        }
        
        .content-view.active {
            display: flex !important;
            flex: 1;
        }
        
        /* Ensure presentation content is visible when active */
        #presentation-content.active {
            background: #1a1a1a !important;
            min-height: 100vh !important;
        }
        
        
        /* Mode switcher button styles */
        .mode-btn:hover {
            background: #f0f0f0 !important;
            color: #333 !important;
        }
        
        .mode-btn.active {
            background: #007acc !important;
            color: white !important;
        }
        
        /* Resizer styles */
        .resizer:hover {
            background: #007acc !important;
        }
        
        /* Force slide content to be light with dark text */
        #presentation-content .slide-content,
        #presentation-content .slide-content *,
        #presentation-root div[style*="background"],
        #presentation-root .bg-white {
            background-color: white !important;
            color: #1f2937 !important;
        }
        
        /* Override any inherited dark styling */
        #presentation-root h1,
        #presentation-root h2, 
        #presentation-root h3,
        #presentation-root h4,
        #presentation-root h5,
        #presentation-root h6,
        #presentation-root p,
        #presentation-root li,
        #presentation-root div {
            color: #1f2937 !important;
        }
        
        /* Preview pane styling - override external CSS */
        #right-pane {
            flex: 1 !important;
            min-width: 0 !important;
            display: flex !important;
            flex-direction: column !important;
            height: calc(100vh - 32px - 40px) !important; /* Account for title bar and mode switcher */
            max-height: calc(100vh - 32px - 40px) !important;
        }
        
        /* Container for content panes - allow flex child to scroll */
        #right-pane > div:last-child {
            flex: 1 !important;
            display: flex !important;
            flex-direction: column !important;
            min-height: 0 !important;
            overflow: hidden !important;
            height: 100% !important;
        }
        
        #preview-pane {
            width: 100% !important;
            height: 100% !important;
            max-height: 100% !important;
            box-sizing: border-box !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            flex: 1 !important;
            min-height: 0 !important;
        }
        
        #preview-content {
            width: 100% !important;
            max-width: 100% !important;
            overflow-wrap: break-word !important;
            word-break: break-word !important;
            padding: 16px !important;
            box-sizing: border-box !important;
            line-height: 1.6 !important;
            height: auto !important;
        }
        
        /* Content pane styling */
        .content-pane {
            width: 100% !important;
            box-sizing: border-box !important;
            overflow-y: auto !important;
            flex: 1 !important;
            min-height: 0 !important;
            position: relative !important;
        }
        
        /* Preview pane image constraints */
        #preview-content img {
            max-width: 100% !important;
            height: auto !important;
            display: block;
            margin: 10px 0;
        }
        
        /* Ensure all preview content elements use full width */
        #preview-content * {
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        /* Presentation mode image constraints */
        #presentation-content img,
        #presentation-root img,
        .slide-content img {
            max-width: 80% !important;
            max-height: 60vh !important;
            height: auto !important;
            width: auto !important;
            display: block !important;
            margin: 20px auto !important;
            object-fit: contain !important;
        }
        
    </style>
    
    <!-- Scripts -->
    <script id="marked-script" src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Tailwind-inspired utility classes for presentation view */
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .h-screen { height: 100vh; }
        .bg-gray-900 { background-color: #1a1a1a; }
        .bg-gray-800 { background-color: #2d2d2d; }
        .bg-gray-700 { background-color: #404040; }
        .bg-gray-600 { background-color: #525252; }
        .bg-blue-600 { background-color: #2563eb; }
        .bg-blue-700 { background-color: #1d4ed8; }
        .bg-green-600 { background-color: #16a34a; }
        .bg-green-700 { background-color: #15803d; }
        .bg-red-600 { background-color: #dc2626; }
        .bg-red-700 { background-color: #b91c1c; }
        .bg-blue-500 { background-color: #3b82f6; }
        .text-white { color: white; }
        .text-gray-900 { color: #1a1a1a; }
        .text-gray-600 { color: #525252; }
        .text-sm { font-size: 0.875rem; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .fixed { position: fixed; }
        .top-4 { top: 1rem; }
        .left-4 { left: 1rem; }
        .right-4 { right: 1rem; }
        .bottom-4 { bottom: 1rem; }
        .bottom-8 { bottom: 2rem; }
        .z-50 { z-index: 50; }
        .left-1\/2 { left: 50%; }
        .z-10 { z-index: 10; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-center { justify-items: center; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-1 { gap: 0.25rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-8 { padding: 2rem; }
        .ml-2 { margin-left: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-0\.75 { margin-bottom: 0.1875rem; }
        .mb-0\.5 { margin-bottom: 0.125rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-xl { border-radius: 0.75rem; }
        .rounded-full { border-radius: 9999px; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .overflow-hidden { overflow: hidden; }
        .transform { transform: var(--tw-transform); }
        .-translate-x-1\/2 { --tw-translate-x: -50%; transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)); }
        .transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .duration-300 { transition-duration: 300ms; }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        .shadow-purple-500\/50 { box-shadow: 0 25px 50px -12px rgba(168, 85, 247, 0.5); }
        .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
        .hover\:bg-gray-600:hover { background-color: #525252; }
        .hover\:bg-green-700:hover { background-color: #15803d; }
        .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .hover\:shadow-3xl:hover { box-shadow: 0 35px 60px -12px rgba(0, 0, 0, 0.3); }
        .hover\:scale-105:hover { transform: scale(1.05); }
        .disabled\:bg-gray-800:disabled { background-color: #2d2d2d; }
        .disabled\:opacity-50:disabled { opacity: 0.5; }
        .active\:cursor-grabbing:active { cursor: grabbing; }
        .border { border-width: 1px; }
        .border-gray-600 { border-color: #525252; }
        .focus\:border-blue-500:focus { border-color: #3b82f6; }
        .outline-none { outline: 2px solid transparent; outline-offset: 2px; }
        .ring-4 { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5); }
        .ring-blue-500 { --tw-ring-color: #3b82f6; }
        .ring-purple-500 { --tw-ring-color: #a855f7; }
        .w-2 { width: 0.5rem; }
        .h-2 { height: 0.5rem; }
        .min-h-400 { min-height: 25rem; }
        
        /* Custom Title Bar */
        .title-bar {
            height: 32px;
            background: #2d2d2d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            -webkit-app-region: drag;
            z-index: 2000;
            user-select: none;
            padding-left: 80px; /* Space for invisible macOS traffic lights */
        }
        
        .title-bar-controls {
            position: absolute;
            right: 10px;
            display: flex;
            gap: 8px;
            -webkit-app-region: no-drag;
        }
        
        .title-bar-button {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: opacity 0.2s;
        }
        
        .title-bar-button:hover {
            opacity: 0.8;
        }
        
        .title-bar-close {
            background: #ff5f57;
        }
        
        .title-bar-minimize {
            background: #ffbd2e;
        }
        
        .title-bar-maximize {
            background: #28ca42;
        }
        
        /* Adjust view containers to account for title bar */
        .view-container {
            height: calc(100vh - 32px);
            margin-top: 0px;
            top: 32px;
            position: absolute;
            width: 100%;
        }
        
        /* Fix mode button highlighting */
        .mode-btn.active {
            background: #007acc !important;
            color: white !important;
        }
        
        .mode-btn:not(.active) {
            background: transparent !important;
            color: #666 !important;
        }
        
        /* Add margins to sidebar headers */
        #structure-pane-header {
            padding: 8px 12px !important;
            margin-top: 4px !important;
        }
        
        #structure-pane-title {
            margin-left: 0 !important;
            margin-top: 4px !important;
        }
        
        /* File tree styling improvements */
        #file-tree-view {
            padding: 8px 12px !important;
            margin-top: 4px !important;
        }
        
        /* Remove all bullet points from file tree */
        #file-tree-view ul {
            list-style: none !important;
            padding-left: 0 !important;
            margin: 0 !important;
        }
        
        #file-tree-view li {
            list-style: none !important;
            padding-left: 0 !important;
            margin-left: 0 !important;
        }
        
        /* Proper indentation for nested items */
        #file-tree-view ul.file-tree-children {
            padding-left: 20px !important;
        }
        
        /* Ensure root folder has no indentation */
        #file-tree-view ul.file-tree-root {
            padding-left: 0 !important;
        }
    </style>
</head>
<body>
    <!-- Custom Title Bar -->
    <div class="title-bar">
        <span id="title-text">Hegel Pedagogy AI</span>
        <div class="title-bar-controls">
            <div class="title-bar-button title-bar-minimize" id="minimize-btn"></div>
            <div class="title-bar-button title-bar-maximize" id="maximize-btn"></div>
            <div class="title-bar-button title-bar-close" id="close-btn"></div>
        </div>
    </div>
    
    <!-- Main Application Container -->
    <div id="app-container" style="display: flex; height: calc(100vh - 32px); margin-top: 32px;">
        <!-- Left Sidebar (Always visible) -->
        <div id="left-sidebar" style="width: 250px; min-width: 200px; max-width: 400px; border-right: 1px solid #ddd; display: flex; flex-direction: column;">
            <div id="structure-pane-header">
                <div class="toggle-buttons structure-toggle-buttons">
                    <button id="show-structure-btn" class="btn pane-toggle-button active" title="Show Document Structure">Structure</button>
                    <button id="show-files-btn" class="btn pane-toggle-button" title="Show File Tree">Files</button>
                </div>
                <h2 id="structure-pane-title">Structure</h2>
            </div>
            <div style="flex: 1; overflow-y: auto;">
                <ul id="structure-list"></ul>
                <div id="file-tree-view" style="display: none;"></div>
            </div>
        </div>

        <!-- Resizer for left sidebar -->
        <div id="sidebar-resizer" class="resizer" style="width: 4px; cursor: ew-resize; background: #ddd;"></div>

        <!-- Main Content Area (Switches between editor and presentation) -->
        <div id="main-content" style="flex: 1; display: flex; flex-direction: column;">
            <!-- Content Mode Switcher -->
            <div id="mode-switcher" style="height: 40px; border-bottom: 1px solid #ddd; display: flex; align-items: center; justify-content: center; background: #f8f9fa;">
                <div style="display: flex; gap: 4px; padding: 4px; background: white; border: 1px solid #ddd; border-radius: 6px;">
                    <button id="editor-mode-btn" class="mode-btn active" style="padding: 6px 16px; border: none; background: #007acc; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">Editor</button>
                    <button id="presentation-mode-btn" class="mode-btn" style="padding: 6px 16px; border: none; background: transparent; color: #666; border-radius: 4px; cursor: pointer; font-size: 12px;">Presentation</button>
                </div>
            </div>

            <!-- Editor Content -->
            <div id="editor-content" class="content-view active">
                <div id="editor-pane" style="flex: 2; min-width: 300px; position: relative;">
                    <div id="editor-container" style="width: 100%; height: 100%;"></div>
                    <textarea id="fallback-editor" style="display: none; width: 100%; height: 100%; box-sizing: border-box; border: 1px solid #ccc; font-family: monospace; padding: 5px;"></textarea>
                </div>
                <div id="resizer" class="resizer" style="width: 4px; cursor: ew-resize; background: #ddd;"></div>
                <div id="right-pane">
                    <div class="toggle-buttons" style="padding: 8px; border-bottom: 1px solid #ddd; flex-shrink: 0;">
                        <button id="show-preview-btn" class="btn pane-toggle-button active">Preview</button>
                        <button id="show-chat-btn" class="btn pane-toggle-button">AI Chat</button>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                        <div id="preview-pane" class="content-pane">
                            <div id="preview-content"></div>
                        </div>
                        <div id="chat-pane" class="content-pane" style="display: none; height: 100%; padding: 16px; flex-direction: column;">
                            <div id="chat-messages" style="flex: 1; overflow-y: auto; margin-bottom: 16px;"></div>
                            <div class="chat-input-area" style="display: flex; flex-direction: column; gap: 8px;">
                                <div style="display: flex; gap: 8px;">
                                    <button id="load-editor-to-chat-btn" class="btn" title="Load Editor Content">Load Editor</button>
                                    <button id="copy-ai-response-btn" class="btn" title="Copy last AI response to editor">Copy to Editor</button>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <textarea id="chat-input" placeholder="Ask the AI..." style="flex: 1; min-height: 60px; resize: vertical;"></textarea>
                                    <button id="chat-send-btn" class="btn">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Presentation Content -->
            <div id="presentation-content" class="content-view">
                <div id="presentation-root" style="width: 100%; height: 100%;"></div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
    // Monaco editor configuration for Electron - disable web workers to avoid file:// issues
    window.MonacoEnvironment = {
        getWorker: function (workerId, label) {
            return undefined; // Disable web workers, use main thread
        }
    };
    
    // Check if Monaco editor resources are available before loading renderer
    if (typeof require !== 'undefined') {
        // Load Monaco editor configuration
        require.config({ 
            paths: { 'vs': './node_modules/monaco-editor/min/vs' },
            'vs/nls': { availableLanguages: { '*': 'en' } }
        });
    }
    </script>
    <script src="./node_modules/monaco-editor/min/vs/loader.js" defer></script>
    <script src="orchestrator/renderer.js" defer></script>
    
    <script type="text/babel">
        // React presentation component
        const { useState, useRef, useEffect, useCallback } = React;
        
        // Check if running in Electron
        const isElectron = window.electronAPI && window.electronAPI.isElectron;

        // Lucide React icons as simple SVG components
        const ChevronLeft = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="15,18 9,12 15,6"></polyline>
            </svg>
        );
        
        const ChevronRight = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9,18 15,12 9,6"></polyline>
            </svg>
        );
        
        const Upload = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7,10 12,15 17,10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );
        
        const ZoomIn = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );
        
        const ZoomOut = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );
        
        const Home = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9,22 9,12 15,12 15,22"></polyline>
            </svg>
        );
        
        const Play = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
        );

        const MarkdownPreziApp = () => {
          console.log('[React Component] MarkdownPreziApp rendering');
          const [slides, setSlides] = useState([]);
          const [currentSlide, setCurrentSlide] = useState(0);
          const [zoom, setZoom] = useState(1);
          const [pan, setPan] = useState({ x: 0, y: 0 });
          const [isDragging, setIsDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [panStart, setPanStart] = useState({ x: 0, y: 0 });
          const [isPresenting, setIsPresenting] = useState(false);
          const [layoutType, setLayoutType] = useState('spiral');
          const [focusedSlide, setFocusedSlide] = useState(null);
          
          console.log('[React Component] Current slides count:', slides.length);
          console.log('[React Component] Current slide index:', currentSlide);
          const canvasRef = useRef(null);
          const fileInputRef = useRef(null);

          // Sample markdown content for demo
          const sampleMarkdown = `# Welcome to Hegel Pedagogy AI
A unified platform for philosophical exploration and learning.

---

## What is This?
- Advanced Markdown editor with AI assistance
- Interactive presentation capabilities
- Integrated file management
- Philosophical content support

---

## Key Features
### Editor Mode
- Monaco editor with syntax highlighting
- Real-time preview
- AI chat integration
- Document structure navigation

### Presentation Mode
- Zoomable presentation canvas
- Multiple layout types
- Smooth transitions
- Interactive navigation

---

## Philosophical Focus
### Hegelian Dialectic
- **Thesis**: Initial position or concept
- **Antithesis**: Negation or contradiction
- **Synthesis**: Higher unity transcending both

### AI & Pedagogy
Integration of artificial intelligence with philosophical education.

---

## Getting Started
1. Switch between Editor and Presentation views
2. Load your Markdown files
3. Use AI chat for assistance
4. Create engaging presentations
5. Explore philosophical concepts

---

## Thank You!
Welcome to the future of philosophical education.

*Happy learning and presenting!*`;

          // Calculate slide positioning based on layout type
          const calculateSlidePosition = (index, total) => {
            const spacing = 800;
            
            switch (layoutType) {
              case 'linear':
                return { x: index * spacing, y: 0 };
                
              case 'grid':
                const cols = Math.ceil(Math.sqrt(total));
                const gridRow = Math.floor(index / cols);
                const col = index % cols;
                return { x: col * spacing, y: gridRow * spacing };
                
              case 'circle':
                if (index === 0) return { x: 0, y: 0 };
                const circleAngle = (index - 1) / (total - 1) * 2 * Math.PI;
                const circleRadius = 600;
                return {
                  x: Math.cos(circleAngle) * circleRadius,
                  y: Math.sin(circleAngle) * circleRadius
                };
                
              case 'spiral':
                if (index === 0) return { x: 0, y: 0 };
                const spiralAngle = (index / total) * 4 * Math.PI;
                const spiralRadius = 300 + (index * 100);
                return {
                  x: Math.cos(spiralAngle) * spiralRadius,
                  y: Math.sin(spiralAngle) * spiralRadius
                };
                
              case 'tree':
                if (index === 0) return { x: 0, y: 0 };
                const level = Math.floor(Math.log2(index + 1));
                const posInLevel = index - (Math.pow(2, level) - 1);
                const maxInLevel = Math.pow(2, level);
                const branchWidth = spacing * maxInLevel;
                return {
                  x: (posInLevel - maxInLevel / 2 + 0.5) * (branchWidth / maxInLevel),
                  y: level * spacing
                };
                
              case 'zigzag':
                const zigzagRow = Math.floor(index / 3);
                const zigzagCol = index % 3;
                const isEvenRow = zigzagRow % 2 === 0;
                return {
                  x: isEvenRow ? zigzagCol * spacing : (2 - zigzagCol) * spacing,
                  y: zigzagRow * spacing
                };
                
              default:
                return { x: 0, y: 0 };
            }
          };

          // Enhanced markdown parser
          const parseMarkdownContent = (content) => {
            let html = content;
            
            // Handle code blocks first
            html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
            
            // Headers
            html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
            html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
            
            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Fix image paths - convert relative paths to absolute file:// URLs
            html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, imagePath) => {
              // Check if this is a relative path
              if (imagePath && !imagePath.startsWith('http') && !imagePath.startsWith('/') && !imagePath.startsWith('file://')) {
                // Use current file directory if available, otherwise fallback to working directory
                const baseDir = window.currentFileDirectory || '/Users/lmagee/Dev/hegel-pedagogy-ai/lectures';
                const fullPath = `file://${baseDir}/${imagePath}`;
                console.log(`[React Presentation] Converting image path: ${imagePath} -> ${fullPath}`);
                return `<img src="${fullPath}" alt="${altText}" />`;
              }
              return `<img src="${imagePath}" alt="${altText}" />`;
            });
            
            // Links
            html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Handle lists
            html = html.replace(/^[\s]*[-*+]\s+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/^[\s]*\d+\.\s+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\s*)+/gs, '<ul>$&</ul>');
            
            // Blockquotes
            html = html.replace(/^>\s+(.+)$/gm, '<blockquote>$1</blockquote>');
            
            // Horizontal rules
            html = html.replace(/^---\s*$/gm, '<hr>');
            
            // Convert remaining text to paragraphs
            const lines = html.split('\n');
            const processedLines = lines.map(line => {
              const trimmed = line.trim();
              if (!trimmed || trimmed.match(/^<(h[1-6]|ul|ol|li|blockquote|pre|hr|div)/)) {
                return line;
              }
              return trimmed ? `<p>${trimmed}</p>` : '';
            });
            
            html = processedLines.join('\n');
            html = html.replace(/\n+/g, '\n');
            html = html.replace(/<p>\s*<\/p>/g, '');
            
            return html;
          };

          // Parse markdown into slides
          const parseMarkdown = (markdown) => {
            const slideTexts = markdown.split('---').map(slide => slide.trim()).filter(slide => slide);
            return slideTexts.map((text, index) => ({
              id: index,
              content: text,
              position: calculateSlidePosition(index, slideTexts.length),
              parsed: parseMarkdownContent(text)
            }));
          };

          // Initialize with sample content (only once)
          useEffect(() => {
            // Check if there's pending content from Generate Summary
            if (window.pendingPresentationContent) {
              console.log('[React Presentation] Found pending content, using it instead of sample');
              const pendingSlides = parseMarkdown(window.pendingPresentationContent);
              setSlides(pendingSlides);
              window.pendingPresentationContent = null; // Clear it after use
            } else {
              console.log('[React Presentation] No pending content, using sample');
              const initialSlides = parseMarkdown(sampleMarkdown);
              setSlides(initialSlides);
            }
          }, []);

          // Listen for content updates from the lecture summary generator
          useEffect(() => {
            const handleContentUpdate = (event) => {
              console.log('[React Presentation] Received content update event');
              console.log('[React Presentation] Event detail:', event.detail);
              const newContent = event.detail?.content;
              console.log('[React Presentation] New content length:', newContent?.length);
              
              if (newContent && newContent.trim()) {
                console.log('[React Presentation] Parsing new content into slides...');
                const newSlides = parseMarkdown(newContent);
                console.log('[React Presentation] Generated slides count:', newSlides.length);
                
                setSlides(newSlides);
                setCurrentSlide(0);
                setZoom(1);
                setPan({ x: 0, y: 0 });
                setFocusedSlide(null);
                console.log('[React Presentation] Successfully updated slides with new content');
              } else {
                console.warn('[React Presentation] No valid content received');
              }
            };

            console.log('[React Presentation] Setting up content update listener');
            window.addEventListener('updatePresentationContent', handleContentUpdate);
            return () => {
              console.log('[React Presentation] Removing content update listener');
              window.removeEventListener('updatePresentationContent', handleContentUpdate);
            };
          }, []);

          // Set up Electron API listeners (only once)
          useEffect(() => {
            if (isElectron && window.electronAPI) {
              // File loading
              window.electronAPI.loadPresentationFile((content, filePath, error) => {
                if (error) {
                  console.error('Error loading file:', error);
                  return;
                }
                if (content) {
                  const newSlides = parseMarkdown(content);
                  setSlides(newSlides);
                  setCurrentSlide(0);
                  setTimeout(() => goToSlide(0), 0);
                }
              });

              // Presentation controls
              window.electronAPI.onStartPresentation(() => {
                setIsPresenting(true);
              });

              window.electronAPI.onExitPresentation(() => {
                setIsPresenting(false);
              });

              window.electronAPI.onTogglePresentationMode(() => {
                // Switch to presentation mode
                switchToMode('presentation');
              });

              // Zoom controls
              window.electronAPI.onZoomIn(() => {
                handleZoomIn();
              });

              window.electronAPI.onZoomOut(() => {
                handleZoomOut();
              });

              window.electronAPI.onResetZoom(() => {
                resetView();
              });

              // Layout changes
              window.electronAPI.onChangeLayout((layout) => {
                setLayoutType(layout);
              });
            }

            return () => {
              if (isElectron && window.electronAPI) {
                window.electronAPI.removeAllListeners();
              }
            };
          }, []);

          // Set up navigation listeners that depend on current state
          useEffect(() => {
            if (isElectron && window.electronAPI) {
              window.electronAPI.onNextSlide(() => {
                goToSlide(currentSlide + 1);
              });

              window.electronAPI.onPreviousSlide(() => {
                goToSlide(currentSlide - 1);
              });

              window.electronAPI.onFirstSlide(() => {
                goToSlide(0);
              });
            }
          }, [currentSlide]);

          // Recalculate positions when layout changes
          useEffect(() => {
            if (slides.length > 0) {
              const updatedSlides = slides.map((slide, index) => ({
                ...slide,
                position: calculateSlidePosition(index, slides.length)
              }));
              setSlides(updatedSlides);
            }
          }, [layoutType]);

          // File upload handler
          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (file && (file.type === 'text/markdown' || file.name.endsWith('.md'))) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const content = e.target.result;
                const newSlides = parseMarkdown(content);
                setSlides(newSlides);
                setCurrentSlide(0);
                goToSlide(0);
              };
              reader.readAsText(file);
            }
          };

          // Navigate to specific slide with smooth transition
          const goToSlide = useCallback((slideIndex) => {
            if (slideIndex < 0 || slideIndex >= slides.length) return;
            
            const slide = slides[slideIndex];
            const canvas = canvasRef.current;
            if (!canvas) return;

            const targetZoom = 1.2;
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            const slideCenterX = slide.position.x;
            const slideCenterY = slide.position.y;
            
            const targetPan = {
              x: viewportCenterX - (slideCenterX * targetZoom),
              y: viewportCenterY - (slideCenterY * targetZoom)
            };

            setCurrentSlide(slideIndex);
            setFocusedSlide(null);
            setZoom(targetZoom);
            setPan(targetPan);
          }, [slides]);

          // Handle double click on slide to zoom in and focus
          const handleSlideDoubleClick = (slideIndex) => {
            const slide = slides[slideIndex];
            const canvas = canvasRef.current;
            if (!canvas) return;

            const targetZoom = 2;
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            const slideCenterX = slide.position.x;
            const slideCenterY = slide.position.y;
            
            const targetPan = {
              x: viewportCenterX - (slideCenterX * targetZoom),
              y: viewportCenterY - (slideCenterY * targetZoom)
            };

            setCurrentSlide(slideIndex);
            setFocusedSlide(slideIndex);
            setZoom(targetZoom);
            setPan(targetPan);
          };

          // Zoom handlers - zoom from current slide center
          const handleZoomIn = () => {
            const newZoom = Math.min(3, zoom * 1.2);
            zoomFromCurrentSlide(newZoom);
          };

          const handleZoomOut = () => {
            const newZoom = Math.max(0.1, zoom * 0.8);
            zoomFromCurrentSlide(newZoom);
          };

          // Helper function to zoom from current slide center
          const zoomFromCurrentSlide = (newZoom) => {
            if (slides.length === 0 || currentSlide >= slides.length) {
              setZoom(newZoom);
              return;
            }

            const canvas = canvasRef.current;
            if (!canvas) {
              setZoom(newZoom);
              return;
            }

            const slide = slides[currentSlide];
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            
            // Calculate the current slide's position on screen
            const currentSlideCenterX = slide.position.x * zoom + pan.x;
            const currentSlideCenterY = slide.position.y * zoom + pan.y;
            
            // Calculate new pan to keep slide centered at new zoom level
            const newPan = {
              x: viewportCenterX - (slide.position.x * newZoom),
              y: viewportCenterY - (slide.position.y * newZoom)
            };

            setZoom(newZoom);
            setPan(newPan);
          };

          const resetView = () => {
            setZoom(1);
            setPan({ x: 0, y: 0 });
            setFocusedSlide(null);
          };

          // Wheel zoom effect
          useEffect(() => {
            const handleWheel = (e) => {
              if (isPresenting) return;
              e.preventDefault();
              const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
              const newZoom = Math.max(0.1, Math.min(3, zoom * zoomFactor));
              setZoom(newZoom);
            };

            const canvas = canvasRef.current;
            if (canvas) {
              canvas.addEventListener('wheel', handleWheel, { passive: false });
              return () => canvas.removeEventListener('wheel', handleWheel);
            }
          }, [zoom, isPresenting]);

          // Keyboard navigation
          useEffect(() => {
            const handleKeyPress = (e) => {
              // Only handle keyboard events if we're in presentation view and not focused on an input element
              const presentationContent = document.getElementById('presentation-content');
              const isInPresentationView = presentationContent && presentationContent.classList.contains('active');
              const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
              
              if (!isInPresentationView || isInputFocused) {
                return; // Don't handle keyboard events if not in presentation view or if an input is focused
              }
              
              if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                goToSlide(currentSlide + 1);
              } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                goToSlide(currentSlide - 1);
              } else if (e.key === 'Home') {
                e.preventDefault();
                goToSlide(0);
              } else if (e.key === 'Escape') {
                setIsPresenting(false);
              }
            };

            window.addEventListener('keydown', handleKeyPress);
            return () => window.removeEventListener('keydown', handleKeyPress);
          }, [currentSlide, goToSlide]);

          // Mouse handlers for panning
          const handleMouseDown = (e) => {
            if (isPresenting) return;
            setIsDragging(true);
            setDragStart({ x: e.clientX, y: e.clientY });
            setPanStart(pan);
          };

          const handleMouseMove = (e) => {
            if (!isDragging || isPresenting) return;
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            setPan({
              x: panStart.x + deltaX,
              y: panStart.y + deltaY
            });
          };

          const handleMouseUp = () => {
            setIsDragging(false);
          };

          return (
            <div className="w-full h-screen relative overflow-hidden" style={{background: 'linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #3b82f6 100%)'}}>
              {/* Controls */}
              {!isPresenting && (
                <div className="absolute top-4 left-4 z-10 flex gap-2">
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="flex items-center gap-2 px-3 py-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <Upload />
                    Load File
                  </button>
                  
                  <select
                    value={layoutType}
                    onChange={(e) => setLayoutType(e.target.value)}
                    className="px-3 py-2 bg-white text-gray-900 rounded-lg border border-gray-300 focus:border-blue-500 outline-none shadow-lg"
                  >
                    <option value="spiral">Spiral</option>
                    <option value="linear">Linear</option>
                    <option value="grid">Grid</option>
                    <option value="circle">Circle</option>
                    <option value="tree">Tree</option>
                    <option value="zigzag">Zigzag</option>
                  </select>
                  
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".md,.markdown"
                    onChange={handleFileUpload}
                    style={{display: 'none'}}
                  />
                </div>
              )}

              {/* Zoom Controls */}
              {!isPresenting && (
                <div className="absolute top-4 right-4 z-10 flex gap-2">
                  <button
                    onClick={handleZoomIn}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <ZoomIn />
                  </button>
                  <button
                    onClick={handleZoomOut}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <ZoomOut />
                  </button>
                  <button
                    onClick={resetView}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <Home />
                  </button>
                  <button
                    onClick={() => setIsPresenting(true)}
                    className="flex items-center gap-2 px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors shadow-lg border border-green-700 text-white"
                  >
                    <Play />
                    Present
                  </button>
                </div>
              )}

              {/* Navigation Controls */}
              <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-4">
                <button
                  onClick={() => goToSlide(currentSlide - 1)}
                  disabled={currentSlide === 0}
                  className="p-3 bg-white hover:bg-gray-100 disabled:bg-gray-300 disabled:opacity-50 rounded-full transition-colors shadow-lg border text-gray-900"
                >
                  <ChevronLeft />
                </button>
                
                <div className="flex items-center gap-2 px-4 py-2 bg-white rounded-lg shadow-lg border text-gray-900">
                  <span className="text-sm">
                    {currentSlide + 1} / {slides.length}
                  </span>
                  {slides.length > 0 && (
                    <div className="flex gap-1 ml-2">
                      {slides.map((_, index) => (
                        <button
                          key={index}
                          onClick={() => goToSlide(index)}
                          className={`w-2 h-2 rounded-full transition-colors ${
                            index === currentSlide ? 'bg-blue-500' : 'bg-gray-400'
                          }`}
                        />
                      ))}
                    </div>
                  )}
                </div>

                <button
                  onClick={() => goToSlide(currentSlide + 1)}
                  disabled={currentSlide === slides.length - 1}
                  className="p-3 bg-white hover:bg-gray-100 disabled:bg-gray-300 disabled:opacity-50 rounded-full transition-colors shadow-lg border text-gray-900"
                >
                  <ChevronRight />
                </button>
              </div>

              {/* Presentation Mode Controls */}
              {isPresenting && (
                <div className="absolute top-4 right-4 z-10 flex gap-2">
                  <button
                    onClick={handleZoomIn}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Zoom In"
                  >
                    <ZoomIn />
                  </button>
                  <button
                    onClick={handleZoomOut}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Zoom Out"
                  >
                    <ZoomOut />
                  </button>
                  <button
                    onClick={resetView}
                    className="p-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Reset Zoom"
                  >
                    <Home />
                  </button>
                  <button
                    onClick={() => setIsPresenting(false)}
                    className="px-4 py-2 bg-white hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    Exit Presentation
                  </button>
                </div>
              )}

              {/* Canvas */}
              <div
                ref={canvasRef}
                className="w-full h-full cursor-grab active:cursor-grabbing"
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                style={{
                  transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                  transformOrigin: 'center center',
                  transition: isDragging ? 'none' : 'transform 0.3s ease-out'
                }}
              >
                <div className="relative w-full h-full flex items-center justify-center">
                  {/* Slides */}
                  {slides.map((slide, index) => {
                    const isFocused = index === focusedSlide;
                    const isCurrent = index === currentSlide;
                    
                    return (
                      <div
                        key={slide.id}
                        className={`absolute bg-white text-gray-900 rounded-xl shadow-2xl transition-all duration-300 cursor-pointer ${
                          isFocused 
                            ? 'ring-4 ring-purple-500 shadow-purple-500/50' 
                            : isCurrent 
                              ? 'ring-4 ring-blue-500' 
                              : 'hover:shadow-3xl hover:scale-105'
                        }`}
                        style={{
                          left: `${slide.position.x}px`,
                          top: `${slide.position.y}px`,
                          width: '600px',
                          minHeight: '400px',
                          transform: 'translate(-50%, -50%)',
                          opacity: isPresenting && index !== currentSlide ? 0.1 : 1,
                          zIndex: isFocused ? 1000 : isCurrent ? 999 : isPresenting && index !== currentSlide ? 0 : 1,
                          position: 'absolute'
                        }}
                        onDoubleClick={() => handleSlideDoubleClick(index)}
                      >
                        <div className="p-8 h-full">
                          <style>{`
                            .slide-content h1 { 
                              font-size: 2.5rem; 
                              font-weight: bold; 
                              margin-bottom: 1rem; 
                              color: #1f2937; 
                              line-height: 1.2;
                            }
                            .slide-content h2 { 
                              font-size: 2rem; 
                              font-weight: 600; 
                              margin-bottom: 0.75rem; 
                              color: #1f2937; 
                              line-height: 1.3;
                            }
                            .slide-content h3 { 
                              font-size: 1.5rem; 
                              font-weight: 500; 
                              margin-bottom: 0.5rem; 
                              color: #1f2937; 
                              line-height: 1.4;
                            }
                            .slide-content p { 
                              margin-bottom: 1rem; 
                              color: #374151; 
                              line-height: 1.6; 
                            }
                            .slide-content ul { 
                              margin-bottom: 1rem; 
                              padding-left: 1.5rem;
                            }
                            .slide-content li { 
                              margin-bottom: 0.5rem; 
                              color: #374151; 
                            }
                            .slide-content strong { 
                              font-weight: bold; 
                            }
                            .slide-content em { 
                              font-style: italic; 
                            }
                            .slide-content code { 
                              background-color: #f3f4f6; 
                              padding: 0.25rem 0.5rem; 
                              border-radius: 0.25rem; 
                              font-family: monospace; 
                              font-size: 0.875rem; 
                            }
                          `}</style>
                          <div 
                            className="slide-content"
                            dangerouslySetInnerHTML={{ __html: slide.parsed }}
                          />
                        </div>
                      </div>
                    );
                  })}

                  {/* Connection Lines */}
                  <svg className="absolute inset-0 pointer-events-none" style={{ width: '200%', height: '200%' }}>
                    {slides.map((slide, index) => {
                      if (index === slides.length - 1) return null;
                      const nextSlide = slides[index + 1];
                      return (
                        <line
                          key={`line-${index}`}
                          x1={slide.position.x + 300}
                          y1={slide.position.y + 200}
                          x2={nextSlide.position.x + 300}
                          y2={nextSlide.position.y + 200}
                          stroke="rgba(255,255,255,0.1)"
                          strokeWidth="2"
                          strokeDasharray="5,5"
                        />
                      );
                    })}
                  </svg>
                </div>
              </div>
            </div>
          );
        };

        // Global content switching functions
        let currentMode = 'editor';
        let presentationEditorContent = '';

        function switchToMode(modeName) {
          console.log('[Mode Switching] Switching to:', modeName);
          
          // Hide all content views
          const contentViews = document.querySelectorAll('.content-view');
          console.log('[Mode Switching] Found content views:', contentViews.length);
          contentViews.forEach(view => {
            console.log('[Mode Switching] Removing active from:', view.id);
            view.classList.remove('active');
          });

          // Show selected content view
          const targetView = document.getElementById(`${modeName}-content`);
          console.log('[Mode Switching] Target view:', targetView);
          if (targetView) {
            targetView.classList.add('active');
            console.log('[Mode Switching] Added active class to:', modeName + '-content');
            console.log('[Mode Switching] Target view classes:', targetView.className);
          } else {
            console.error('[Mode Switching] Could not find target view:', modeName + '-content');
          }

          // Update mode buttons
          const modeButtons = document.querySelectorAll('.mode-btn');
          modeButtons.forEach(btn => btn.classList.remove('active'));
          
          const targetButton = document.getElementById(`${modeName}-mode-btn`);
          if (targetButton) {
            targetButton.classList.add('active');
          }

          // Handle mode-specific logic
          if (modeName === 'presentation') {
            document.body.classList.add('presentation-mode');
            
            // Ensure React component is rendered
            const presentationRoot = document.getElementById('presentation-root');
            if (presentationRoot) {
              console.log('[Mode Switching] Rendering React presentation component for presentation mode');
              try {
                ReactDOM.render(React.createElement(MarkdownPreziApp), presentationRoot);
                console.log('[Mode Switching] React component rendered successfully');
              } catch (error) {
                console.error('[Mode Switching] Error rendering React component:', error);
              }
            }
            
            // Check for pending content first (from Generate Summary)
            if (window.pendingPresentationContent) {
              console.log('[Mode Switching] Applying pending presentation content');
              const contentUpdateEvent = new CustomEvent('updatePresentationContent', {
                detail: { content: window.pendingPresentationContent }
              });
              window.dispatchEvent(contentUpdateEvent);
            }
            // Otherwise, sync editor content if available
            else {
              // Try to get current editor content
              let currentContent = '';
              if (window.editor && typeof window.editor.getValue === 'function') {
                currentContent = window.editor.getValue();
                console.log('[Mode Switching] Got content from Monaco editor, length:', currentContent.length);
              } else if (presentationEditorContent) {
                currentContent = presentationEditorContent;
                console.log('[Mode Switching] Using stored presentation content, length:', currentContent.length);
              }
              
              if (currentContent && window.syncContentToPresentation) {
                console.log('[Mode Switching] Syncing content to presentation');
                window.syncContentToPresentation(currentContent);
              } else {
                console.log('[Mode Switching] No content to sync or sync function not available');
              }
            }
          } else {
            document.body.classList.remove('presentation-mode');
          }

          currentMode = modeName;
        }

        // Set up mode switching
        function setupModeSwitching() {
          console.log('[Mode Switching] Setting up mode switching...');

          // Set up mode button event listeners
          const editorModeBtn = document.getElementById('editor-mode-btn');
          const presentationModeBtn = document.getElementById('presentation-mode-btn');

          if (editorModeBtn) {
            editorModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Editor mode button clicked');
              switchToMode('editor');
            });
          }

          if (presentationModeBtn) {
            presentationModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Presentation mode button clicked');
              switchToMode('presentation');
            });
          }

          // Render React presentation component
          const presentationRoot = document.getElementById('presentation-root');
          if (presentationRoot) {
            console.log('[Mode Switching] Rendering React presentation component');
            console.log('[Mode Switching] Presentation root element:', presentationRoot);
            try {
              ReactDOM.render(React.createElement(MarkdownPreziApp), presentationRoot);
              console.log('[Mode Switching] React component rendered successfully');
            } catch (error) {
              console.error('[Mode Switching] Error rendering React component:', error);
            }
          } else {
            console.error('[Mode Switching] Could not find presentation-root element');
          }

          // Store content for presentation mode
          window.pendingPresentationContent = null;
          
          // Set up content synchronization
          window.syncContentToPresentation = (content) => {
            console.log('Syncing content to presentation, content length:', content?.length);
            
            // Store the content for later use
            window.pendingPresentationContent = content;
            
            // Try to update the presentation immediately
            const contentUpdateEvent = new CustomEvent('updatePresentationContent', {
              detail: { content: content }
            });
            window.dispatchEvent(contentUpdateEvent);
            console.log('[Content Sync] Stored content and dispatched updatePresentationContent event');
          };

          // Set up IPC event listeners for lecture summary generation
          if (window.electronAPI) {
            window.electronAPI.onLoadPresentationContent((content) => {
              console.log('[IPC] Received presentation content to load');
              window.syncContentToPresentation(content);
            });

            window.electronAPI.onSwitchToPresentation(() => {
              console.log('[IPC] Switching to presentation mode');
              switchToMode('presentation');
            });

            window.electronAPI.onSwitchToEditor(() => {
              console.log('[IPC] Switching to editor mode');
              switchToMode('editor');
            });
          }

          // Set up title bar controls (only in Electron)
          if (window.electronAPI && window.electronAPI.isElectron) {
            const minimizeBtn = document.getElementById('minimize-btn');
            const maximizeBtn = document.getElementById('maximize-btn');
            const closeBtn = document.getElementById('close-btn');

            if (minimizeBtn) {
              minimizeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Minimize clicked');
                // Add minimize functionality if needed
              });
            }

            if (maximizeBtn) {
              maximizeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Maximize clicked');
                // Add maximize functionality if needed
              });
            }

            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Close clicked');
                if (window.electronAPI.closeWindow) {
                  window.electronAPI.closeWindow();
                } else {
                  window.close();
                }
              });
            }
          } else {
            // Hide title bar controls on web
            const titleBarControls = document.querySelector('.title-bar-controls');
            if (titleBarControls) {
              titleBarControls.style.display = 'none';
            }
          }

          // Hide custom controls on macOS since native ones are invisible but functional
          if (window.electronAPI && window.electronAPI.platform === 'darwin') {
            const titleBarControls = document.querySelector('.title-bar-controls');
            if (titleBarControls) {
              titleBarControls.style.display = 'none';
            }
          }
        }

        // Try setup immediately and on DOMContentLoaded
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setupModeSwitching);
        } else {
          setupModeSwitching();
        }

        // Expose mode switching globally
        window.switchToMode = switchToMode;
    </script>
</body>
</html>