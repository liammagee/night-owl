<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://cdn.tailwindcss.com 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        font-src 'self' data:;
        img-src 'self' data:;
        connect-src 'self';
        worker-src 'self' blob:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hegel Pedagogy AI - Advanced Editor & Presentations</title>
    <link rel="icon" type="image/png" href="build/icon.png">
    <link rel="icon" type="image/svg+xml" href="build/icon.svg">
    
    <!-- Styles -->
    <link rel="stylesheet" href="orchestrator/style.css">
    <style>
        /* Content view styles */
        .content-view {
            display: none !important;
        }
        
        .content-view.active {
            display: flex !important;
            flex: 1;
        }
        
        /* Ensure presentation content is visible when active */
        #presentation-content.active {
            background: #1a1a1a !important;
            min-height: 100vh !important;
        }
        
        /* Active Presenting Mode - Hide everything except presentation and speaker notes */
        body.is-presenting #left-sidebar {
            display: none !important;
        }
        
        body.is-presenting #sidebar-resizer {
            display: none !important;
        }
        
        body.is-presenting #editor-container {
            display: none !important;
        }
        
        body.is-presenting #mode-switcher {
            display: none !important;
        }
        
        body.is-presenting #editor-toolbar {
            display: none !important;
        }
        
        body.is-presenting #preview-pane,
        body.is-presenting #chat-pane,
        body.is-presenting #graph-content,
        body.is-presenting #network-content,
        body.is-presenting #circle-content {
            display: none !important;
        }
        
        body.is-presenting #right-pane {
            flex: 1 !important;
            width: 100% !important;
            max-width: 100% !important;
        }
        
        body.is-presenting #presentation-content {
            display: flex !important;
            width: 100% !important;
            height: 100vh !important;
        }
        
        body.is-presenting #main-content {
            height: 100vh !important;
        }
        
        body.is-presenting .resizer {
            display: none !important;
        }
        
        /* Ensure speaker notes remain visible in presenting mode - full width at bottom */
        body.is-presenting #speaker-notes-panel {
            display: block !important;
            position: fixed !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            z-index: 1000 !important;
        }
        
        /* Adjust presentation content when speaker notes are visible */
        body.is-presenting #presentation-root {
            height: calc(100vh - 200px) !important; /* Default height adjustment */
            overflow: hidden !important;
        }
        
        /* Ensure speaker notes text is readable */
        body.is-presenting #current-slide-notes {
            font-size: 14px !important; /* Slightly larger for easier reading */
            line-height: 1.6 !important;
        }
        
        /* Restore visibility when NOT actively presenting */
        body:not(.is-presenting) #left-sidebar {
            display: flex !important;
        }
        
        body:not(.is-presenting) #sidebar-resizer {
            display: block !important;
        }
        
        body:not(.is-presenting) #editor-container {
            display: flex !important;
        }
        
        body:not(.is-presenting) #mode-switcher {
            display: flex !important;
        }
        
        body:not(.is-presenting) #editor-toolbar {
            display: flex !important;
        }
        
        body:not(.is-presenting) .resizer {
            display: block !important;
        }
        
        body:not(.is-presenting) #main-content {
            height: auto !important;
        }
        
        body:not(.is-presenting) #right-pane {
            flex: 1 !important;
            width: auto !important;
            max-width: none !important;
        }
        
        
        /* Mode switcher button styles */
        .mode-btn:hover {
            background: #f0f0f0 !important;
            color: #333 !important;
        }
        
        .mode-btn.active {
            background: #16a34a !important;
            color: white !important;
        }
        
        /* Resizer styles */
        .resizer:hover {
            background: #16a34a !important;
        }
        
        /* Allow presentation templates to style slides */
        /* Removed forced white background to allow template styles */
        
        /* Override any inherited dark styling */
        /* Removed hardcoded dark color to allow templates to control text color */
        
        /* Preview pane styling - override external CSS */
        #right-pane {
            flex: 1 !important;
            min-width: 0 !important;
            display: flex !important;
            flex-direction: column !important;
            background-color: #fefdfb !important;
        }
        
        /* Container for content panes - allow flex child to scroll */
        #right-pane > div:last-child {
            flex: 1 !important;
            display: flex !important;
            flex-direction: column !important;
            min-height: 0 !important;
            overflow: hidden !important;
            height: 100% !important;
            background-color: #fefdfb !important;
        }
        
        #preview-pane {
            width: 100% !important;
            height: 100% !important;
            max-height: 100% !important;
            box-sizing: border-box !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            flex: 1 !important;
            min-height: 0 !important;
            background-color: #fefdfb !important;
        }
        
        #preview-content {
            width: 100% !important;
            max-width: 100% !important;
            overflow-wrap: break-word !important;
            word-break: break-word !important;
            padding: 16px !important;
            box-sizing: border-box !important;
            line-height: 1.6 !important;
            height: auto !important;
            background-color: #fefdfb !important;
        }
        
        /* Content pane styling */
        .content-pane {
            width: 100% !important;
            box-sizing: border-box !important;
            overflow-y: auto !important;
            flex: 1 !important;
            min-height: 0 !important;
            position: relative !important;
            background-color: #fefdfb !important;
        }
        
        /* Preview pane image constraints */
        #preview-content img {
            max-width: 100% !important;
            height: auto !important;
            display: block;
            margin: 10px 0;
        }
        
        /* Ensure all preview content elements use full width */
        #preview-content * {
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        /* Presentation mode image constraints */
        #presentation-content img,
        #presentation-root img,
        .slide-content img {
            max-width: 80% !important;
            max-height: 60vh !important;
            height: auto !important;
            width: auto !important;
            display: block !important;
            margin: 20px auto !important;
            object-fit: contain !important;
        }
        
        /* Context Menu Styling */
        :root {
            --bg-color: #ffffff;
            --text-color: #212529;
            --border-color: #dee2e6;
            --hover-color: #f8f9fa;
        }

        .dark-mode {
            --bg-color: #2d3748;
            --text-color: #e2e8f0;
            --border-color: #4a5568;
            --hover-color: #4a5568;
        }

        .context-menu {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .context-menu-item:hover {
            transition: background-color 0.15s ease-in-out;
        }

        .notification {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Visual feedback for cut items */
        .file-tree li[style*="opacity: 0.5"] {
            position: relative;
        }

        .file-tree li[style*="opacity: 0.5"]::after {
            content: "‚úÇÔ∏è";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
        }

        /* Drag and drop styling */
        .file-tree li[draggable="true"] {
            cursor: move;
            user-select: none;
        }

        .file-tree li[draggable="true"]:hover {
            background-color: var(--hover-color, #f8f9fa);
        }

        .file-tree .folder.drag-over {
            background-color: var(--hover-color, #e3f2fd) !important;
            border: 2px solid #007bff !important;
        }

        .file-tree .dragging {
            opacity: 0.5 !important;
            border: 2px dashed #007bff !important;
        }

        /* Editor Toolbar Styling */
        .toolbar-btn:hover {
            background: var(--hover-color, #e9ecef) !important;
            border-color: #adb5bd !important;
        }

        .toolbar-btn:active {
            background: var(--hover-color, #dee2e6) !important;
            transform: translateY(1px);
        }

        .dark-mode #editor-toolbar {
            background: var(--bg-color, #2d3748) !important;
            border-bottom-color: var(--border-color, #4a5568) !important;
            color: var(--text-color, #e2e8f0) !important;
        }

        .dark-mode .toolbar-btn {
            background: var(--bg-color, #4a5568) !important;
            border-color: var(--border-color, #718096) !important;
            color: var(--text-color, #e2e8f0) !important;
        }

        /* Navigation Button Styling */
        .nav-btn {
            transition: all 0.15s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background: var(--hover-color, #e9ecef) !important;
            border-color: #adb5bd !important;
        }

        .nav-btn:active:not(:disabled) {
            background: var(--hover-color, #dee2e6) !important;
            transform: translateY(1px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
        }

        .dark-mode #mode-switcher {
            background: var(--bg-color, #2d3748) !important;
            border-bottom-color: var(--border-color, #4a5568) !important;
            color: var(--text-color, #e2e8f0) !important;
        }

        .dark-mode .nav-btn {
            background: var(--bg-color, #4a5568) !important;
            border-color: var(--border-color, #718096) !important;
            color: var(--text-color, #e2e8f0) !important;
        }

        .dark-mode #current-file-name {
            color: var(--text-color, #a0aec0) !important;
        }

        /* Global Search Styling */
        .search-result-item {
            border: 1px solid #e9ecef;
            border-radius: 4px;
            margin-bottom: 8px;
            background: #fefdfb;
            overflow: hidden;
        }

        .search-result-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-result-header:hover {
            background: #e9ecef;
        }

        .search-result-matches {
            max-height: 200px;
            overflow-y: auto;
        }

        .search-match {
            padding: 4px 12px;
            border-bottom: 1px solid #f8f9fa;
            cursor: pointer;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .search-match:hover {
            background: #f8f9fa;
        }

        .search-match:last-child {
            border-bottom: none;
        }

        .search-match-line {
            color: #666;
            font-size: 11px;
            margin-right: 8px;
            min-width: 40px;
            display: inline-block;
        }

        .search-match-text {
            white-space: pre-wrap;
        }

        .search-highlight {
            background: #fff3cd;
            color: #856404;
            font-weight: bold;
            padding: 1px 2px;
            border-radius: 2px;
        }

        .search-no-results {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 40px 20px;
        }

        .search-loading {
            text-align: center;
            color: #6c757d;
            padding: 20px;
        }

        /* Dark mode search styling */
        .dark-mode .search-result-item {
            background: var(--bg-color, #2d3748);
            border-color: var(--border-color, #4a5568);
        }

        .dark-mode .search-result-header {
            background: var(--bg-color, #4a5568);
            border-bottom-color: var(--border-color, #718096);
            color: var(--text-color, #e2e8f0);
        }

        .dark-mode .search-result-header:hover {
            background: var(--hover-color, #718096);
        }

        .dark-mode .search-match {
            border-bottom-color: var(--border-color, #4a5568);
            color: var(--text-color, #e2e8f0);
        }

        .dark-mode .search-match:hover {
            background: var(--hover-color, #4a5568);
        }

        .dark-mode .search-match-line {
            color: var(--text-color, #a0aec0);
        }

        .dark-mode .search-highlight {
            background: #fbbf24;
            color: #92400e;
        }
    </style>
    
    <!-- Scripts -->
    <script id="marked-script" src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                tags: 'ams'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- D3.js v7.8.5 (local copy) for visualizations and whole/part diagrams -->
    <script src="lib/d3.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Tailwind-inspired utility classes for presentation view */
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .h-screen { height: 100vh; }
        .bg-gray-900 { background-color: #1a1a1a; }
        .bg-gray-800 { background-color: #2d2d2d; }
        .bg-gray-700 { background-color: #404040; }
        .bg-gray-600 { background-color: #525252; }
        .bg-blue-600 { background-color: #16a34a; }
        .bg-blue-700 { background-color: #15803d; }
        .bg-green-600 { background-color: #16a34a; }
        .bg-green-700 { background-color: #15803d; }
        .bg-red-600 { background-color: #dc2626; }
        .bg-red-700 { background-color: #b91c1c; }
        .bg-blue-500 { background-color: #22c55e; }
        .bg-cream { background-color: #fefdfb; }
        .text-white { color: white; }
        .text-gray-900 { color: #1a1a1a; }
        .text-gray-600 { color: #525252; }
        .text-sm { font-size: 0.875rem; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .fixed { position: fixed; }
        .top-4 { top: 1rem; }
        .left-4 { left: 1rem; }
        .right-4 { right: 1rem; }
        .bottom-4 { bottom: 1rem; }
        .bottom-8 { bottom: 2rem; }
        .z-50 { z-index: 50; }
        .left-1\/2 { left: 50%; }
        .z-10 { z-index: 10; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-center { justify-items: center; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-1 { gap: 0.25rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-8 { padding: 2rem; }
        .ml-2 { margin-left: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-0\.75 { margin-bottom: 0.1875rem; }
        .mb-0\.5 { margin-bottom: 0.125rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-xl { border-radius: 0.75rem; }
        .rounded-full { border-radius: 9999px; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .overflow-hidden { overflow: hidden; }
        .transform { transform: var(--tw-transform); }
        .-translate-x-1\/2 { --tw-translate-x: -50%; transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)); }
        .transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .duration-300 { transition-duration: 300ms; }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        .shadow-purple-500\/50 { box-shadow: 0 25px 50px -12px rgba(168, 85, 247, 0.5); }
        .hover\:bg-blue-700:hover { background-color: #15803d; }
        .hover\:bg-gray-600:hover { background-color: #525252; }
        .hover\:bg-green-700:hover { background-color: #15803d; }
        .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .hover\:shadow-3xl:hover { box-shadow: 0 35px 60px -12px rgba(0, 0, 0, 0.3); }
        .hover\:scale-105:hover { transform: scale(1.05); }
        .disabled\:bg-gray-800:disabled { background-color: #2d2d2d; }
        .disabled\:opacity-50:disabled { opacity: 0.5; }
        .active\:cursor-grabbing:active { cursor: grabbing; }
        .border { border-width: 1px; }
        .border-gray-600 { border-color: #525252; }
        .focus\:border-blue-500:focus { border-color: #22c55e; }
        .outline-none { outline: 2px solid transparent; outline-offset: 2px; }
        .ring-4 { box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.5); }
        .ring-blue-500 { --tw-ring-color: #22c55e; }
        .ring-purple-500 { --tw-ring-color: #a855f7; }
        .w-2 { width: 0.5rem; }
        .h-2 { height: 0.5rem; }
        .min-h-400 { min-height: 25rem; }
        
        /* Mode button styling */
        .mode-btn {
            transition: all 0.2s ease;
        }
        
        .mode-btn:hover {
            background: #f0f0f0 !important;
        }
        
        .mode-btn.active {
            background: #16a34a !important;
            color: white !important;
        }
        
        /* Network visualization styles */
        #network-canvas svg {
            cursor: grab;
        }
        
        #network-canvas svg:active {
            cursor: grabbing;
        }
        
        /* Custom Title Bar */
        .title-bar {
            height: 32px;
            background: #2d2d2d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            -webkit-app-region: drag;
            z-index: 2000;
            user-select: none;
            padding-left: 80px; /* Space for invisible macOS traffic lights */
        }
        
        .title-bar-controls {
            position: absolute;
            right: 10px;
            display: flex;
            gap: 8px;
            -webkit-app-region: no-drag;
        }
        
        .title-bar-button {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: opacity 0.2s;
        }
        
        .title-bar-button:hover {
            opacity: 0.8;
        }
        
        .title-bar-close {
            background: #ff5f57;
        }
        
        .title-bar-minimize {
            background: #ffbd2e;
        }
        
        .title-bar-maximize {
            background: #28ca42;
        }
        
        /* Adjust view containers to account for title bar */
        .view-container {
            height: calc(100vh - 32px);
            margin-top: 0px;
            top: 32px;
            position: absolute;
            width: 100%;
        }
        
        /* Fix mode button highlighting */
        .mode-btn.active {
            background: #16a34a !important;
            color: white !important;
        }
        
        .mode-btn:not(.active) {
            background: transparent !important;
            color: #666 !important;
        }
        
        /* Add margins to sidebar headers */
        #structure-pane-header {
            padding: 8px 12px !important;
            margin-top: 4px !important;
        }
        
        #structure-pane-title {
            margin-left: 0 !important;
            margin-top: 4px !important;
        }
        
        /* File tree styling improvements */
        #file-tree-view {
            padding: 8px 12px !important;
            margin-top: 4px !important;
        }
        
        /* Remove all bullet points from file tree */
        #file-tree-view ul {
            list-style: none !important;
            padding-left: 0 !important;
            margin: 0 !important;
        }
        
        #file-tree-view li {
            list-style: none !important;
            padding-left: 0 !important;
            margin-left: 0 !important;
        }
        
        /* Proper indentation for nested items */
        #file-tree-view ul.file-tree-children {
            padding-left: 20px !important;
        }
        
        /* Ensure root folder has no indentation */
        #file-tree-view ul.file-tree-root {
            padding-left: 0 !important;
        }

        /* File tree item styling */
        .file-tree-item {
            display: flex;
            align-items: center;
            padding: 2px 4px;
            margin: 1px 0;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
            font-size: 13px;
            line-height: 1.4;
        }

        .file-tree-item:hover {
            background-color: #f0f0f0;
        }

        body.dark-mode .file-tree-item:hover {
            background-color: #404040;
        }

        .file-tree-item.folder {
            font-weight: 500;
        }

        .file-tree-item.file {
            font-weight: normal;
        }

        .file-tree-item .expand-arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 12px;
            height: 12px;
        }

        .file-tree-item .file-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        .file-tree-item .file-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* File tree main content */
        .file-tree-main {
            display: flex;
            align-items: center;
        }

        /* File tags display */
        .file-tags {
            margin-top: 2px;
            margin-left: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 10px;
            opacity: 0.7;
        }

        .file-tag {
            background: var(--primary-500);
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
            display: inline-block;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        body.dark-mode .file-tag {
            background: var(--primary-600);
            color: var(--neutral-100);
        }

        .file-tree-item:hover .file-tags {
            opacity: 1;
        }

        /* Tag search interface */
        #tag-search-input {
            transition: border-color 0.2s;
        }

        #tag-search-input:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 1px var(--primary-500);
        }

        body.dark-mode #tag-search-input {
            background: var(--neutral-800);
            border-color: var(--neutral-600);
            color: var(--text-color);
        }

        body.dark-mode #tag-search-input:focus {
            border-color: var(--primary-500);
        }

        /* Tag filter chips */
        .tag-chip {
            background: var(--primary-100);
            color: var(--primary-700);
            border: 1px solid var(--primary-300);
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tag-chip:hover {
            background: var(--primary-200);
        }

        .tag-chip.active {
            background: var(--primary-500);
            color: white;
            border-color: var(--primary-500);
        }

        .tag-chip-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            line-height: 1;
        }

        body.dark-mode .tag-chip {
            background: var(--primary-900);
            color: var(--primary-200);
            border-color: var(--primary-700);
        }

        body.dark-mode .tag-chip:hover {
            background: var(--primary-800);
        }

        body.dark-mode .tag-chip.active {
            background: var(--primary-600);
            color: white;
        }

        /* Status bar styling */
        #editor-status-bar {
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        
        /* Dark mode status bar */
        body.dark-mode #editor-status-bar {
            background: #2d2d2d !important;
            border-top-color: #444 !important;
            color: #ccc !important;
        }

        /* Internal link styling (Obsidian-style) */
        .internal-link {
            color: #6366f1 !important;
            text-decoration: none !important;
            background: rgba(99, 102, 241, 0.1) !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            border: 1px solid rgba(99, 102, 241, 0.2) !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }

        .internal-link:hover {
            background: rgba(99, 102, 241, 0.2) !important;
            border-color: rgba(99, 102, 241, 0.4) !important;
            text-decoration: none !important;
        }

        /* Dark mode internal links */
        body.dark-mode .internal-link {
            color: #8b5cf6 !important;
            background: rgba(139, 92, 246, 0.15) !important;
            border-color: rgba(139, 92, 246, 0.3) !important;
        }

        body.dark-mode .internal-link:hover {
            background: rgba(139, 92, 246, 0.25) !important;
            border-color: rgba(139, 92, 246, 0.5) !important;
        }

        /* Find & Replace Dialog */
        #find-replace-dialog {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
            background: #fefdfb;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px;
            min-width: 320px;
            font-size: 14px;
        }

        #find-replace-dialog.hidden {
            display: none;
        }

        body.dark-mode #find-replace-dialog {
            background: #2d2d2d;
            border-color: #444;
            color: #e0e0e0;
        }

        .find-replace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .find-replace-close {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            color: #666;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.dark-mode .find-replace-close {
            color: #ccc;
        }

        .find-replace-close:hover {
            color: #333;
        }

        body.dark-mode .find-replace-close:hover {
            color: white;
        }

        .find-replace-field {
            margin-bottom: 8px;
        }

        .find-replace-field label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #666;
        }

        body.dark-mode .find-replace-field label {
            color: #ccc;
        }

        .find-replace-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        body.dark-mode .find-replace-input {
            background: #333;
            border-color: #555;
            color: #e0e0e0;
        }

        .find-replace-input:focus {
            outline: none;
            border-color: #16a34a;
        }

        .find-replace-options {
            display: flex;
            gap: 12px;
            margin: 12px 0;
            font-size: 12px;
        }

        .find-replace-option {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .find-replace-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .find-replace-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #333;
        }

        .find-replace-btn:hover {
            background: #e9ecef;
        }

        .find-replace-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.dark-mode .find-replace-btn {
            background: #404040;
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-mode .find-replace-btn:hover:not(:disabled) {
            background: #4a4a4a;
        }

        .find-replace-primary {
            background: #16a34a;
            color: white;
            border-color: #16a34a;
        }

        .find-replace-primary:hover:not(:disabled) {
            background: #005a9e;
        }

        .find-replace-stats {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
        }

        body.dark-mode .find-replace-stats {
            color: #aaa;
        }

        /* Monaco Editor Search Highlights */
        .monaco-editor .findMatch {
            background-color: rgba(234, 92, 0, 0.33);
        }

        .monaco-editor .currentFindMatch {
            background-color: rgba(234, 92, 0, 0.66);
        }

        /* Folder Name Dialog */
        #folder-name-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #folder-name-modal.hidden {
            display: none;
        }

        .folder-name-dialog {
            background: #fefdfb;
            border-radius: 8px;
            padding: 24px;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode .folder-name-dialog {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .folder-name-header {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 16px;
            color: #333;
        }

        body.dark-mode .folder-name-header {
            color: #e0e0e0;
        }

        .folder-name-field {
            margin-bottom: 20px;
        }

        .folder-name-field label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            color: #555;
        }

        body.dark-mode .folder-name-field label {
            color: #ccc;
        }

        .folder-name-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        body.dark-mode .folder-name-input {
            background: #333;
            border-color: #555;
            color: #e0e0e0;
        }

        .folder-name-input:focus {
            outline: none;
            border-color: #16a34a;
        }

        .folder-name-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .folder-name-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }

        .folder-name-btn:hover {
            background: #e9ecef;
        }

        body.dark-mode .folder-name-btn {
            background: #404040;
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-mode .folder-name-btn:hover {
            background: #4a4a4a;
        }

        .folder-name-btn.primary {
            background: #16a34a;
            color: white;
            border-color: #16a34a;
        }

        .folder-name-btn.primary:hover {
            background: #005a9e;
        }

        .folder-name-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Custom Title Bar -->
    <div class="title-bar">
        <span id="title-text">Hegel Pedagogy AI</span>
        <div class="title-bar-controls">
            <div class="title-bar-button title-bar-minimize" id="minimize-btn"></div>
            <div class="title-bar-button title-bar-maximize" id="maximize-btn"></div>
            <div class="title-bar-button title-bar-close" id="close-btn"></div>
        </div>
    </div>
    
    <!-- Main Application Container -->
    <div id="app-container">
        <!-- Left Sidebar (Always visible) -->
        <div id="left-sidebar">
            <div id="structure-pane-header">
                <div class="toggle-buttons structure-toggle-buttons">
                    <button id="show-files-btn" class="btn pane-toggle-button" title="Show File Tree">Files</button>
                    <button id="show-structure-btn" class="btn pane-toggle-button active" title="Show Document Structure">Structure</button>
                </div>
                <!-- Tag search interface (only visible in Files view) -->
                <div id="tag-search-section" style="display: none; margin-top: 4px;">
                    <input type="text" id="tag-search-input" placeholder="Search files by tags..." style="width: 100%; padding: 4px 8px; border: 1px solid var(--neutral-300); border-radius: 4px; font-size: 11px; background: var(--neutral-0);">
                    <div id="tag-filter-chips" style="margin-top: 4px; display: flex; flex-wrap: wrap; gap: 4px; min-height: 20px;"></div>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 4px;">
                    <h2 id="structure-pane-title">Structure</h2>
                    <div style="display: flex; gap: 4px;">
                        <button id="change-directory-btn" class="btn" title="Change Working Directory" style="display: none; padding: 4px 8px; font-size: 11px;">üìÅ Directory</button>
                        <button id="new-folder-btn" class="btn" title="Create New Folder" style="padding: 4px 8px; font-size: 11px;">+ Folder</button>
                    </div>
                </div>
            </div>
            <div style="flex: 1; overflow-y: auto;">
                <ul id="structure-list"></ul>
                <div id="file-tree-view" style="display: none;"></div>
                <!-- TEMP DEBUG: Test button -->
            </div>
        </div>

        <!-- Resizer for left sidebar -->
        <div id="sidebar-resizer" class="resizer" style="width: 4px; cursor: ew-resize; background: #ddd;"></div>

        <!-- Main Content Area (Switches between editor and presentation) -->
        <div id="main-content">
            <!-- Content Mode Switcher -->
            <div id="mode-switcher" style="height: 40px; border-bottom: 1px solid #ddd; display: flex; align-items: center; justify-content: space-between; background: #f8f9fa; padding: 0 16px;">
                <!-- Navigation Controls -->
                <div id="navigation-controls" style="display: flex; align-items: center; gap: 4px;">
                    <button id="nav-back-btn" class="nav-btn" title="Go Back (Alt+Left)" disabled style="padding: 6px 10px; border: 1px solid #ccc; background: #fefdfb; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                        ‚Üê Back
                    </button>
                    <button id="nav-forward-btn" class="nav-btn" title="Go Forward (Alt+Right)" disabled style="padding: 6px 10px; border: 1px solid #ccc; background: #fefdfb; border-radius: 4px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                        Forward ‚Üí
                    </button>
                    <div style="width: 1px; height: 20px; background: #ccc; margin: 0 8px;"></div>
                    <span id="current-file-name" style="font-size: 11px; color: #666; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        No file selected
                    </span>
                </div>
                
                <!-- Mode Switcher -->
                <div style="display: flex; gap: 4px; padding: 4px; background: #fefdfb; border: 1px solid #ddd; border-radius: 6px;">
                    <button id="editor-mode-btn" class="mode-btn active" style="padding: 6px 16px; border: none; background: #16a34a; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">Editor</button>
                    <button id="presentation-mode-btn" class="mode-btn" style="padding: 6px 16px; border: none; background: transparent; color: #666; border-radius: 4px; cursor: pointer; font-size: 12px;">Presentation</button>
                    <button id="network-mode-btn" class="mode-btn" style="padding: 6px 16px; border: none; background: transparent; color: #666; border-radius: 4px; cursor: pointer; font-size: 12px;">Network</button>
                    <button id="graph-mode-btn" class="mode-btn" style="padding: 6px 16px; border: none; background: transparent; color: #666; border-radius: 4px; cursor: pointer; font-size: 12px;">Graph</button>
                    <button id="circle-mode-btn" class="mode-btn" style="padding: 6px 16px; border: none; background: transparent; color: #666; border-radius: 4px; cursor: pointer; font-size: 12px;">Circle</button>
                </div>
                
                <!-- Pane Toggle Controls -->
                <div style="display: flex; gap: 4px; align-items: center;">
                    <span style="font-size: 11px; color: #666; margin-right: 4px;">Panes:</span>
                    <button id="toggle-sidebar-btn" class="btn" title="Toggle Files/Structure Pane" style="padding: 4px 8px; font-size: 11px; background: #16a34a; color: white; border-radius: 3px;">üìÅ</button>
                    <button id="toggle-editor-btn" class="btn" title="Toggle Editor Pane" style="padding: 4px 8px; font-size: 11px; background: #16a34a; color: white; border-radius: 3px;">üìù</button>
                    <button id="toggle-preview-btn" class="btn" title="Toggle Preview Pane" style="padding: 4px 8px; font-size: 11px; background: #16a34a; color: white; border-radius: 3px;">üëÅ</button>
                </div>
            </div>

            <!-- Editor Content -->
            <div id="editor-content" class="content-view active">
                <!-- Editor Toolbar (spans both editor and preview panes) -->
                <div id="editor-toolbar">
                        <!-- Markdown Formatting Tools -->
                        <button id="format-bold-btn" class="toolbar-btn toolbar-btn-bold" title="Bold (Ctrl+B)">
                            B
                        </button>
                        <button id="format-italic-btn" class="toolbar-btn toolbar-btn-italic" title="Italic (Ctrl+I)">
                            I
                        </button>
                        <button id="format-code-btn" class="toolbar-btn toolbar-btn-code" title="Inline Code (Ctrl+`)">
                            &lt;&gt;
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="format-h1-btn" class="toolbar-btn toolbar-btn-bold" title="Heading 1">
                            H1
                        </button>
                        <button id="format-h2-btn" class="toolbar-btn toolbar-btn-bold" title="Heading 2">
                            H2
                        </button>
                        <button id="format-h3-btn" class="toolbar-btn toolbar-btn-bold" title="Heading 3">
                            H3
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="format-list-btn" class="toolbar-btn" title="Bulleted List">
                            ‚Ä¢
                        </button>
                        <button id="format-numbered-list-btn" class="toolbar-btn" title="Numbered List">
                            1.
                        </button>
                        <button id="format-quote-btn" class="toolbar-btn" title="Blockquote">
                            &gt;
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="format-inline-math-btn" class="toolbar-btn toolbar-btn-code" title="Inline Math ($...$)">
                            $x$
                        </button>
                        <button id="format-display-math-btn" class="toolbar-btn toolbar-btn-code" title="Display Math ($$...$$)">
                            $$
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="format-link-btn" class="toolbar-btn" title="Insert Link (Ctrl+K)">
                            üîó
                        </button>
                        <button id="format-image-btn" class="toolbar-btn" title="Insert Image">
                            üñºÔ∏è
                        </button>
                        <button id="format-table-btn" class="toolbar-btn" title="Insert Table">
                            üìä
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="auto-slide-markers-btn" class="toolbar-btn" title="Add Slide Markers to Paragraphs">
                            üìÑ‚Üí
                        </button>
                        <button id="remove-slide-markers-btn" class="toolbar-btn" title="Remove All Slide Markers">
                            üìÑ‚úñÔ∏è
                        </button>
                        <button id="insert-speaker-notes-btn" class="toolbar-btn" title="Insert Speaker Notes Template">
                            üìù
                        </button>
                        <button id="insert-toc-btn" class="toolbar-btn" title="Insert Table of Contents">
                            üìë+
                        </button>
                        <button id="remove-toc-btn" class="toolbar-btn" title="Remove Table of Contents">
                            üìë‚úñÔ∏è
                        </button>
                        
                        <div class="toolbar-separator"></div>
                        
                        <button id="command-palette-btn" class="toolbar-btn" title="Command Palette (Cmd+Shift+P)">
                            üéØ
                        </button>
                        
                        <!-- Annotation Controls -->
                        <div class="toolbar-separator"></div>
                        <button id="insert-comment-annotation-btn" class="toolbar-btn" title="Insert Comment Annotation">
                            üí¨
                        </button>
                        <button id="insert-highlight-annotation-btn" class="toolbar-btn" title="Insert Highlight Annotation">
                            üü°
                        </button>
                        <button id="insert-block-annotation-btn" class="toolbar-btn" title="Insert Block Annotation">
                            üìã
                        </button>
                        
                        <div class="toolbar-separator"></div>
                        <span style="font-size: 11px; color: #666;">Format</span>
                        <div class="toolbar-separator"></div>
                        <button id="fold-all-btn" class="toolbar-btn" title="Fold All Sections (Ctrl+K, Ctrl+0)">
                            üìÅ
                        </button>
                        <button id="unfold-all-btn" class="toolbar-btn" title="Unfold All Sections (Ctrl+K, Ctrl+J)">
                            üìÇ
                        </button>
                        <button id="fold-current-btn" class="toolbar-btn" title="Fold Current Section (Ctrl+Shift+[)">
                            ‚¨áÔ∏è
                        </button>
                        <button id="unfold-current-btn" class="toolbar-btn" title="Unfold Current Section (Ctrl+Shift+])">
                            ‚¨ÜÔ∏è
                        </button>
                        <div class="toolbar-separator"></div>
                        <button id="global-search-btn" class="toolbar-btn" title="Global Search (Ctrl+Shift+F)">
                            üîç
                        </button>
                        <button id="ai-todo-suggestions-btn" class="toolbar-btn" title="Get AI TODO Suggestions">
                            ü§ñ
                        </button>
                        <button id="invoke-ash-btn" class="toolbar-btn" title="Invoke Ash (AI Writing Companion) - Cmd+Shift+'">
                            üí¨
                        </button>
                </div>
                <!-- Container for editor and preview panes -->
                <div id="panes-container" style="display: flex; flex: 1; overflow: hidden;">
                    <div id="editor-pane">
                        <div id="editor-container" style="width: 100%; flex: 1;"></div>
                        <textarea id="fallback-editor" style="display: none; width: 100%; flex: 1; box-sizing: border-box; border: 1px solid #ccc; font-family: monospace; padding: 5px;"></textarea>
                        <!-- Status Bar -->
                        <div id="editor-status-bar" style="height: 24px; background: #f8f9fa; border-top: 1px solid #ddd; display: flex; align-items: center; justify-content: space-between; padding: 0 12px; font-size: 12px; color: #666; flex-shrink: 0;">
                            <div id="status-left" style="display: flex; align-items: center; gap: 12px;">
                                <span id="word-count">Words: 0</span>
                                <span id="char-count">Characters: 0</span>
                                <span id="line-count">Lines: 1</span>
                            </div>
                            <div id="status-right" style="display: flex; align-items: center; gap: 12px;">
                                <span id="cursor-position">Ln 1, Col 1</span>
                                <span id="file-status">Markdown (.md)</span>
                            </div>
                        </div>
                    </div>
                    <div id="resizer" class="resizer" style="width: 4px; cursor: ew-resize; background: #ddd;"></div>
                    <div id="right-pane">
                    <div class="toggle-buttons" style="padding: 8px; border-bottom: 1px solid #ddd; flex-shrink: 0;">
                        <button id="show-preview-btn" class="btn pane-toggle-button active">Preview</button>
                        <button id="show-chat-btn" class="btn pane-toggle-button">AI Chat</button>
                        <button id="show-search-btn" class="btn pane-toggle-button">Search</button>
                        <button id="show-speaker-notes-btn" class="btn pane-toggle-button">üìù Notes</button>
                        <button id="show-wholepart-btn" class="btn pane-toggle-button">üîó Relations</button>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                        <div id="preview-pane" class="content-pane">
                            <div id="preview-content"></div>
                        </div>
                        <div id="chat-pane" class="content-pane terminal-chat" style="display: none;">
                            <div class="terminal-header">
                                <span class="terminal-title">Chat with Ash</span>
                                <span class="terminal-subtitle" id="chat-context-display">Your AI writing companion ‚Ä¢ Type /help for commands</span>
                            </div>
                            <div id="chat-messages" class="terminal-output" style="flex: 1; overflow-y: auto; margin-bottom: 16px;"></div>
                            <div class="terminal-input-area" style="display: flex; align-items: center; gap: 8px;">
                                <span class="terminal-prompt-line">
                                    <span class="terminal-user">you</span><span class="terminal-separator">:</span> 
                                </span>
                                <input type="text" id="chat-input" class="terminal-input" placeholder="Ask Ash anything about your writing..." style="flex: 1;">
                                <div class="terminal-buttons" style="display: flex; gap: 4px;">
                                    <button id="restart-chat-btn" class="btn btn-small" title="Start new chat session">üîÑ</button>
                                    <button id="load-editor-to-chat-btn" class="btn btn-small" title="Load current editor content into chat">üìù</button>
                                    <button id="copy-ai-response-btn" class="btn btn-small" title="Insert last AI response at cursor position">üìã</button>
                                </div>
                            </div>
                        </div>
                        <div id="search-pane" class="content-pane" style="display: none; height: 100%; padding: 12px; flex-direction: column;">
                            <!-- Global Search and Replace Interface -->
                            <div class="search-controls" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px;">
                                <div style="padding: 8px; background: #f0f7ff; border-radius: 4px; margin-bottom: 8px; font-size: 12px; color: #0066cc;">
                                    üí° <strong>Tip:</strong> Search will include tags, metadata (title, category, description), and file content. Click on tags in results to filter files.
                                </div>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="global-search-input" placeholder="Search in all files, tags, and metadata..." style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 3px;">
                                    <button id="global-search-execute" class="btn" title="Execute Search">Search</button>
                                </div>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="global-replace-input" placeholder="Replace with..." style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 3px;">
                                    <button id="global-replace-execute" class="btn" title="Replace All Matches" style="background: #dc3545; color: white;">Replace All</button>
                                    <button id="global-replace-preview" class="btn" title="Preview Replacements">Preview</button>
                                </div>
                                <div class="search-options" style="display: flex; gap: 12px; font-size: 12px;">
                                    <label style="display: flex; align-items: center; gap: 4px;">
                                        <input type="checkbox" id="search-case-sensitive"> Case Sensitive
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 4px;">
                                        <input type="checkbox" id="search-whole-word"> Whole Word
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 4px;">
                                        <input type="checkbox" id="search-regex"> Regex
                                    </label>
                                </div>
                                <div class="search-file-types" style="display: flex; gap: 8px; align-items: center; font-size: 12px;">
                                    <span>Files:</span>
                                    <input type="text" id="search-file-pattern" placeholder="*.md, *.txt" style="flex: 1; padding: 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 11px;">
                                </div>
                            </div>
                            
                            <!-- Search Results -->
                            <div class="search-results-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 4px 0; border-bottom: 1px solid #eee;">
                                <span id="search-results-count" style="font-size: 12px; color: #666;">No search performed</span>
                                <button id="clear-search-results" class="btn" style="padding: 2px 6px; font-size: 11px;" title="Clear Results">Clear</button>
                            </div>
                            <div id="search-results" style="flex: 1; overflow-y: auto; font-size: 13px;"></div>
                        </div>
                        
                        <div id="speaker-notes-pane" class="content-pane" style="display: none; height: 100%; padding: 12px; flex-direction: column;">
                            <!-- Speaker Notes Interface -->
                            <div class="speaker-notes-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #007bff;">
                                <h3 style="margin: 0; color: #007bff; font-size: 16px;">üìù Speaker Notes</h3>
                                <button id="toggle-speaker-notes-in-preview" class="btn" style="padding: 4px 8px; font-size: 11px;" title="Toggle Notes in Preview">Show in Preview</button>
                            </div>
                            
                            <div id="speaker-notes-content" style="flex: 1; overflow-y: auto; font-size: 14px; line-height: 1.6;">
                                <p style="color: #666; text-align: center; padding: 20px;">
                                    No speaker notes found.<br>
                                    <small>Add notes using <code>```notes</code> blocks in your Markdown.</small>
                                </p>
                            </div>
                            
                            <div class="speaker-notes-help" style="margin-top: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #666;">
                                <strong>Tip:</strong> Use <code>```notes</code> in your Markdown to add speaker notes that won't appear on slides.
                            </div>
                        </div>

                        <div id="wholepart-pane" class="content-pane" style="display: none; height: 100%; flex-direction: column;">
                            <!-- Whole/Part Relations Interface -->
                            <div class="wholepart-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px 12px; border-bottom: 2px solid #4ecdc4;">
                                <h3 style="margin: 0; color: #4ecdc4; font-size: 16px;">üîó Concept Relations</h3>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <select id="wholepart-visualization-type" style="padding: 4px 8px; font-size: 11px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="0">Circular Ring</option>
                                        <option value="1">Center-Radial</option>
                                        <option value="2">Containment</option>
                                        <option value="3">Spiral Center</option>
                                        <option value="4">Spiral Parts</option>
                                        <option value="5">Dialectical</option>
                                        <option value="6">Spiral Radial</option>
                                        <option value="7">Fractal</option>
                                        <option value="8">Nested</option>
                                    </select>
                                    <button id="wholepart-refresh" class="btn" style="padding: 4px 8px; font-size: 11px;" title="Refresh Data">üîÑ</button>
                                </div>
                            </div>
                            
                            <div id="wholepart-description" style="padding: 8px 12px; background: #f8f9fa; border-radius: 4px; margin: 0 12px 12px 12px; font-size: 12px; color: #555;">
                                <strong>Visualization:</strong> <span id="wholepart-description-text">Select a visualization to explore concept relationships.</span>
                            </div>
                            
                            <div id="wholepart-visualization" style="flex: 1; overflow: hidden; margin: 0 12px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fefdfb;">
                                <!-- D3 visualization will be rendered here -->
                            </div>
                            
                            <div class="wholepart-controls" style="display: flex; justify-content: center; gap: 8px; padding: 8px 12px; border-top: 1px solid #e0e0e0;">
                                <button id="wholepart-animate" class="btn" style="padding: 4px 12px; font-size: 11px;">‚ñ∂Ô∏è Animate</button>
                                <button id="wholepart-reset" class="btn" style="padding: 4px 12px; font-size: 11px;">üîÑ Reset</button>
                                <button id="wholepart-zoom-in" class="btn" style="padding: 4px 8px; font-size: 11px;">+</button>
                                <button id="wholepart-zoom-out" class="btn" style="padding: 4px 8px; font-size: 11px;">-</button>
                            </div>
                        </div>
                    </div>
                </div>
                </div> <!-- End panes-container -->
            </div>

            <!-- Presentation Content -->
            <div id="presentation-content" class="content-view" style="display: flex; flex-direction: column; position: relative;">
                <div id="presentation-root" style="width: 100%; flex: 1; min-height: 0;"></div>
                <div id="speaker-notes-panel" style="position: absolute; bottom: 0; left: 0; right: 0; height: 180px; background: #2c3e50; color: white; border-top: 3px solid #34495e; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; display: none; z-index: 1000; box-shadow: 0 -2px 10px rgba(0,0,0,0.3); min-height: 80px; max-height: 60vh;">
                    <!-- Resize Handle -->
                    <div id="speaker-notes-resize-handle" style="position: absolute; top: 0; left: 0; right: 0; height: 8px; background: #34495e; cursor: ns-resize; border-radius: 4px 4px 0 0; display: flex; align-items: center; justify-content: center;">
                        <div style="width: 40px; height: 3px; background: #7f8c8d; border-radius: 2px;"></div>
                    </div>
                    <!-- Header -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 16px 16px 8px 16px; padding-top: 8px;">
                        <h4 style="margin: 0; font-size: 14px; color: #ecf0f1;">üìù Speaker Notes</h4>
                        <button id="toggle-speaker-notes-panel" style="background: #34495e; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">Hide</button>
                    </div>
                    <!-- Scrollable Content -->
                    <div id="current-slide-notes" style="font-size: 13px; line-height: 1.4; color: #bdc3c7; padding: 0 16px 16px 16px; overflow-y: auto; height: calc(100% - 60px);">
                        <em>No speaker notes for this slide.</em>
                    </div>
                </div>
            </div>
            
            <!-- Network Visualization Content -->
            <div id="network-content" class="content-view" style="display: flex; flex-direction: column; position: relative;">
                <div id="network-visualization" style="width: 100%; flex: 1; min-height: 0; background: #f8f9fa;">
                    <div id="network-canvas" style="width: 100%; height: 100%; position: relative;">
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;">
                            <div style="font-size: 24px; margin-bottom: 10px;">üìä</div>
                            <div>Loading network visualization...</div>
                        </div>
                    </div>
                    
                    <!-- Network Controls Panel -->
                    <div id="network-controls" style="position: absolute; top: 10px; right: 10px; background: #fefdfb; padding: 10px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 12px;">
                        <div style="margin-bottom: 8px; font-weight: bold;">Network Controls</div>
                        <button id="network-refresh" class="btn" style="margin-right: 5px; padding: 4px 8px; font-size: 11px;">üîÑ Refresh</button>
                        <button id="network-center" class="btn" style="margin-right: 5px; padding: 4px 8px; font-size: 11px;">üéØ Center</button>
                        <button id="network-fit" class="btn" style="padding: 4px 8px; font-size: 11px;">üìê Fit</button>
                        <div style="margin-top: 8px; font-size: 11px; color: #666;">
                            <div id="network-stats">Files: 0 | Links: 0</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Graph Visualization Content -->
            <div id="graph-content" class="content-view" style="display: flex; flex-direction: column; position: relative;">
                <div id="graph-visualization" style="width: 100%; flex: 1; min-height: 0; background: #1e1e1e;">
                    <!-- Graph will be rendered here by graph.js module -->
                </div>
            </div>
            
            <!-- Circle Visualization Content -->
            <div id="circle-content" class="content-view" style="display: flex; flex-direction: column; position: relative;">
                <div id="circle-visualization" style="width: 100%; flex: 1; min-height: 0; background: #fafafa;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üîÑ</div>
                        <div>Hermeneutic Circle</div>
                        <div style="font-size: 12px; margin-top: 5px; color: #999;">Exploring iterative understanding patterns</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Find & Replace Dialog -->
    <div id="find-replace-dialog" class="hidden">
        <div class="find-replace-header">
            <span>Find & Replace</span>
            <button class="find-replace-close" id="find-replace-close">&times;</button>
        </div>
        
        <div class="find-replace-field">
            <label for="find-input">Find:</label>
            <input type="text" id="find-input" class="find-replace-input" placeholder="Enter search text">
        </div>
        
        <div class="find-replace-field">
            <label for="replace-input">Replace:</label>
            <input type="text" id="replace-input" class="find-replace-input" placeholder="Enter replacement text">
        </div>
        
        <div class="find-replace-options">
            <label class="find-replace-option">
                <input type="checkbox" id="case-sensitive"> Case sensitive
            </label>
            <label class="find-replace-option">
                <input type="checkbox" id="regex-mode"> Regex
            </label>
            <label class="find-replace-option">
                <input type="checkbox" id="whole-word"> Whole word
            </label>
        </div>
        
        <div class="find-replace-actions">
            <button class="find-replace-btn find-replace-primary" id="find-next">Find Next</button>
            <button class="find-replace-btn" id="find-previous">Find Previous</button>
            <button class="find-replace-btn" id="replace-current">Replace</button>
            <button class="find-replace-btn" id="replace-all">Replace All</button>
        </div>
        
        <div class="find-replace-stats" id="find-replace-stats">
            <!-- Stats will be populated by JavaScript -->
        </div>
    </div>

    <!-- Folder Name Modal -->
    <div id="folder-name-modal" class="hidden">
        <div class="folder-name-dialog">
            <div class="folder-name-header">Create New Folder</div>
            
            <div class="folder-name-field">
                <label for="folder-name-input">Folder name:</label>
                <input type="text" id="folder-name-input" class="folder-name-input" placeholder="Enter folder name">
                <div class="folder-name-error" id="folder-name-error"></div>
            </div>
            
            <div class="folder-name-actions">
                <button class="folder-name-btn" id="folder-name-cancel">Cancel</button>
                <button class="folder-name-btn primary" id="folder-name-create">Create</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
    // Monaco editor configuration for Electron - disable web workers to avoid file:// issues
    window.MonacoEnvironment = {
        getWorker: function (workerId, label) {
            return undefined; // Disable web workers, use main thread
        }
    };
    
    // Check if Monaco editor resources are available before loading renderer
    if (typeof require !== 'undefined') {
        // Load Monaco editor configuration
        require.config({ 
            paths: { 'vs': './node_modules/monaco-editor/min/vs' },
            'vs/nls': { availableLanguages: { '*': 'en' } }
        });
    }
    </script>
    <script src="./node_modules/monaco-editor/min/vs/loader.js" defer></script>
    
    <!-- Load modules first -->
    <script src="orchestrator/modules/internalLinks.js" defer></script>
    <script src="orchestrator/modules/annotations.js" defer></script>
    <script src="orchestrator/modules/formatting.js" defer></script>
    <script src="orchestrator/modules/aiChat.js" defer></script>
    <script src="orchestrator/modules/export.js" defer></script>
    <script src="orchestrator/modules/search.js" defer></script>
    <script src="orchestrator/modules/findReplace.js" defer></script>
    <script src="orchestrator/modules/navigation.js" defer></script>
    <script src="orchestrator/modules/commandPalette.js" defer></script>
    <script src="orchestrator/modules/kanban.js" defer></script>
    <script src="orchestrator/modules/settings.js" defer></script>
    <script src="orchestrator/modules/listManagement.js" defer></script>
    <script src="orchestrator/modules/speakerNotes.js" defer></script>
    <script src="orchestrator/modules/autosave.js" defer></script>
    <!-- D3.js v7.8.5 already loaded above with React/Babel -->
    <script src="orchestrator/modules/wholepart.js" defer></script>
    <!-- AI Assistant Configuration -->
    <script src="orchestrator/modules/ai-assistant-config.js" defer></script>
    <!-- AI Writing Companion - Modular Architecture -->
    <script src="orchestrator/modules/ai-companion/analysis/TextAnalysisEngine.js" defer></script>
    <script src="orchestrator/modules/ai-companion/context/ContextManager.js" defer></script>
    <script src="orchestrator/modules/ai-companion/feedback/FeedbackSystem.js" defer></script>
    <script src="orchestrator/modules/ai-companion/AICompanionManager.js" defer></script>
    <!-- Gamification System - Modular Architecture -->
    <script src="orchestrator/modules/gamification/core/WritingSession.js" defer></script>
    <script src="orchestrator/modules/gamification/timers/FocusTimer.js" defer></script>
    <script src="orchestrator/modules/gamification/core/FlowState.js" defer></script>
    <script src="orchestrator/modules/gamification/data/DataPersistence.js" defer></script>
    <script src="orchestrator/modules/gamification/GamificationManager.js" defer></script>
    <script src="orchestrator/modules/collaborative-challenges.js" defer></script>
    <script src="orchestrator/modules/challenges-ui.js" defer></script>
    <!-- AI Flow Detection - Modular System -->
    <script src="orchestrator/modules/ai-flow-detection/TextCollectionManager.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/TypingPatternAnalyzer.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/CognitiveLoadAssessment.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/FlowStateEngine.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/InsightsEngine.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/FlowIndicatorUI.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/AIFlowDetectionManager.js" defer></script>
    <script src="orchestrator/modules/ai-flow-detection/index.js" defer></script>
    <script src="orchestrator/modules/todo-gamification.js" defer></script>
    <script src="orchestrator/modules/dragdrop.js" defer></script>
    <script src="orchestrator/modules/previewZoom.js" defer></script>
    <script src="orchestrator/modules/fileFilters.js" defer></script>
    <script src="orchestrator/modules/tagManager.js" defer></script>
    <script type="module" src="orchestrator/modules/graph.js" defer></script>
    <script type="module" src="orchestrator/modules/circle.js" defer></script>
    
    <!-- Style management modules -->
    <script src="styles/style-manager.js" defer></script>
    <script src="styles/style-settings-ui.js" defer></script>
    
    <!-- Main renderer script -->
    <script src="orchestrator/renderer.js" defer></script>
    
    <script type="text/babel">
        // React presentation component
        const { useState, useRef, useEffect, useCallback } = React;
        
        // Check if running in Electron
        const isElectron = window.electronAPI && window.electronAPI.isElectron;

        // Lucide React icons as simple SVG components
        const ChevronLeft = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="15,18 9,12 15,6"></polyline>
            </svg>
        );
        
        const ChevronRight = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9,18 15,12 9,6"></polyline>
            </svg>
        );
        
        const Upload = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7,10 12,15 17,10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );
        
        const ZoomIn = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );
        
        const ZoomOut = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );
        
        const Home = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9,22 9,12 15,12 15,22"></polyline>
            </svg>
        );
        
        const Play = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
        );

        const MarkdownPreziApp = () => {
          // React component rendering
          const [slides, setSlides] = useState([]);
          const [currentSlide, setCurrentSlide] = useState(0);
          const [zoom, setZoom] = useState(1);
          const [pan, setPan] = useState({ x: 0, y: 0 });
          const [isDragging, setIsDragging] = useState(false);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [panStart, setPanStart] = useState({ x: 0, y: 0 });
          const [isPresenting, setIsPresenting] = useState(false);
          const [layoutType, setLayoutType] = useState('spiral');
          const [focusedSlide, setFocusedSlide] = useState(null);
          const [speakerNotesVisible, setSpeakerNotesVisible] = useState(true);
          
          // Current slides and slide index state
          const canvasRef = useRef(null);
          const containerRef = useRef(null);

          // Sample markdown content for demo
          const sampleMarkdown = `# SAMPLE CONTENT TEST
This is sample content to test speaker notes.

\`\`\`notes
üî¥ SAMPLE SPEAKER NOTES: If you can see this, the speaker notes parsing is working correctly!

This is a test of the speaker notes functionality in presentation mode.
\`\`\`

---

## What is This?
- Advanced Markdown editor with AI assistance
- Interactive presentation capabilities
- Integrated file management
- Philosophical content support

\`\`\`notes
Explain each bullet point briefly:

1. Advanced editor - mention Monaco editor, syntax highlighting
2. Presentation capabilities - this is what they're seeing now!
3. File management - integrated file tree, folder operations
4. Philosophical content - specifically designed for philosophy education

Ask if anyone has questions about the core features before moving on.
\`\`\`

---

## Key Features
### Editor Mode
- Monaco editor with syntax highlighting
- Real-time preview
- AI chat integration
- Document structure navigation

### Presentation Mode
- Zoomable presentation canvas
- Multiple layout types
- Smooth transitions
- Interactive navigation

\`\`\`notes
Demonstrate the dual modes:

Editor Mode:
- Show how the editor looks
- Mention real-time preview
- AI chat for philosophical discussions

Presentation Mode:
- This is what we're in right now
- Mention zoom capabilities (demonstrate if needed)
- Different layouts available (spiral, grid, linear, circle)

Transition: "Now let's talk about the philosophical foundation..."
\`\`\`

---

## Philosophical Focus
### Hegelian Dialectic
- **Thesis**: Initial position or concept
- **Antithesis**: Negation or contradiction
- **Synthesis**: Higher unity transcending both

### AI & Pedagogy
Integration of artificial intelligence with philosophical education.

\`\`\`notes
This is the core philosophical concept we're exploring:

Hegelian Dialectic explanation:
- Thesis: Starting point, initial idea
- Antithesis: Opposition, contradiction, challenge
- Synthesis: Resolution that preserves and transcends both

Give a concrete example if time permits - maybe democracy/authoritarianism -> constitutional democracy.

AI & Pedagogy:
- Not replacing human instruction
- Augmenting and enhancing learning
- Helping students explore complex philosophical concepts
\`\`\`

---

## Getting Started
1. Switch between Editor and Presentation views
2. Load your Markdown files
3. Use AI chat for assistance
4. Create engaging presentations
5. Explore philosophical concepts

\`\`\`notes
Practical steps for new users:

1. Mode switching - use the buttons at the top
2. File loading - integrated file system
3. AI assistance - context-aware help for philosophical concepts
4. Presentations - what they're experiencing now
5. Exploration - encourage experimentation

Remind them that speaker notes like these are available in presentation mode!

Next: Thank them and open for questions.
\`\`\`

---

## Thank You!
Welcome to the future of philosophical education.

*Happy learning and presenting!*

\`\`\`notes
Closing remarks:

- Thank the audience for their attention
- Emphasize the innovative nature of combining AI with philosophy
- Invite questions and discussion
- Mention that this is just the beginning

End with: "Are there any questions about the platform or its philosophical applications?"

Note: You can press 'N' to toggle these speaker notes on/off during presentation.
\`\`\``;

          // Calculate slide positioning based on layout type
          const calculateSlidePosition = (index, total) => {
            const spacing = 800;
            
            switch (layoutType) {
              case 'linear':
                return { x: index * spacing, y: 0 };
                
              case 'grid':
                const cols = Math.ceil(Math.sqrt(total));
                const gridRow = Math.floor(index / cols);
                const col = index % cols;
                return { x: col * spacing, y: gridRow * spacing };
                
              case 'circle':
                if (index === 0) return { x: 0, y: 0 };
                const circleAngle = (index - 1) / (total - 1) * 2 * Math.PI;
                const circleRadius = 600;
                return {
                  x: Math.cos(circleAngle) * circleRadius,
                  y: Math.sin(circleAngle) * circleRadius
                };
                
              case 'spiral':
                if (index === 0) return { x: 0, y: 0 };
                const spiralAngle = (index / total) * 4 * Math.PI;
                const spiralRadius = 300 + (index * 100);
                return {
                  x: Math.cos(spiralAngle) * spiralRadius,
                  y: Math.sin(spiralAngle) * spiralRadius
                };
                
              case 'tree':
                if (index === 0) return { x: 0, y: 0 };
                const level = Math.floor(Math.log2(index + 1));
                const posInLevel = index - (Math.pow(2, level) - 1);
                const maxInLevel = Math.pow(2, level);
                const branchWidth = spacing * maxInLevel;
                return {
                  x: (posInLevel - maxInLevel / 2 + 0.5) * (branchWidth / maxInLevel),
                  y: level * spacing
                };
                
              case 'zigzag':
                const zigzagRow = Math.floor(index / 3);
                const zigzagCol = index % 3;
                const isEvenRow = zigzagRow % 2 === 0;
                return {
                  x: isEvenRow ? zigzagCol * spacing : (2 - zigzagCol) * spacing,
                  y: zigzagRow * spacing
                };
                
              default:
                return { x: 0, y: 0 };
            }
          };

          // Enhanced markdown parser
          const parseMarkdownContent = (content) => {
            let html = content;
            
            // Handle code blocks first
            html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
            
            // Headers
            html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
            html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
            
            // Bold and italic
            html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Fix image paths - convert relative paths to absolute file:// URLs
            html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, imagePath) => {
              // Check if this is a relative path
              if (imagePath && !imagePath.startsWith('http') && !imagePath.startsWith('/') && !imagePath.startsWith('file://')) {
                // Use current file directory if available, otherwise fallback to working directory
                const baseDir = window.currentFileDirectory || '/Users/lmagee/Dev/hegel-pedagogy-ai/lectures';
                const fullPath = `file://${baseDir}/${imagePath}`;
                console.log(`[React Presentation] Converting image path: ${imagePath} -> ${fullPath}`);
                return `<img src="${fullPath}" alt="${altText}" />`;
              }
              return `<img src="${imagePath}" alt="${altText}" />`;
            });
            
            // Process math expressions before other markdown to preserve them
            // Note: We preserve LaTeX math syntax for MathJax to process later
            // This ensures math expressions don't get processed as other markdown
            
            // Process Obsidian-style [[]] internal links first
            html = html.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, link, displayText) => {
              const cleanLink = link.trim();
              const display = displayText ? displayText.trim() : cleanLink;
              let filePath = cleanLink;
              if (!filePath.endsWith('.md') && !filePath.includes('.')) {
                filePath += '.md';
              }
              return `<a href="#" class="internal-link" data-link="${encodeURIComponent(filePath)}" data-original-link="${encodeURIComponent(cleanLink)}" title="Open ${display}">${display}</a>`;
            });
            
            // Regular markdown links
            html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Handle lists
            html = html.replace(/^[\s]*[-*+]\s+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/^[\s]*\d+\.\s+(.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\s*)+/gs, '<ul>$&</ul>');
            
            // Blockquotes
            html = html.replace(/^>\s+(.+)$/gm, '<blockquote>$1</blockquote>');
            
            // Horizontal rules
            html = html.replace(/^---\s*$/gm, '<hr>');
            
            // Convert remaining text to paragraphs
            const lines = html.split('\n');
            const processedLines = lines.map(line => {
              const trimmed = line.trim();
              if (!trimmed || trimmed.match(/^<(h[1-6]|ul|ol|li|blockquote|pre|hr|div)/)) {
                return line;
              }
              return trimmed ? `<p>${trimmed}</p>` : '';
            });
            
            html = processedLines.join('\n');
            html = html.replace(/\n+/g, '\n');
            html = html.replace(/<p>\s*<\/p>/g, '');
            
            return html;
          };

          // Extract speaker notes from slide content
          const extractSpeakerNotes = (slideContent) => {
            // Extracting speaker notes
            
            // More flexible regex pattern for speaker notes
            const notesRegex = /```notes\s*\n([\s\S]*?)\n```/g;
            const notes = [];
            let match;
            
            while ((match = notesRegex.exec(slideContent)) !== null) {
              const noteContent = match[1].trim();
              // Found speaker note
              notes.push(noteContent);
            }
            
            // Remove speaker notes from slide content (more flexible pattern)
            const cleanContent = slideContent.replace(/```notes\s*\n[\s\S]*?\n```/g, '').trim();
            
            const result = { 
              cleanContent, 
              speakerNotes: notes.join('\n\n') 
            };
            
            // Speaker notes extraction complete
            return result;
          };

          // Parse markdown into slides
          const parseMarkdown = (markdown) => {
            const slideTexts = markdown.split('---').map(slide => slide.trim()).filter(slide => slide);
            return slideTexts.map((text, index) => {
              const { cleanContent, speakerNotes } = extractSpeakerNotes(text);
              return {
                id: index,
                content: text,
                cleanContent: cleanContent,
                speakerNotes: speakerNotes,
                position: calculateSlidePosition(index, slideTexts.length),
                parsed: parseMarkdownContent(cleanContent) // Parse only clean content
              };
            });
          };

          // Initialize - wait for content from editor or use sample as fallback
          useEffect(() => {
            // Initializing presentation component
            
            // Brief delay to allow content synchronization from editor
            const initTimeout = setTimeout(() => {
              // Check if there's pending content from Generate Summary or fresh editor content
              if (window.pendingPresentationContent) {
                // Found pending content, using it
                const pendingSlides = parseMarkdown(window.pendingPresentationContent);
                setSlides(pendingSlides);
                window.pendingPresentationContent = null; // Clear it after use
              } else {
                // No pending content, using sample content
                const initialSlides = parseMarkdown(sampleMarkdown);
                setSlides(initialSlides);
              }
            }, 100); // Small delay to allow content synchronization
            
            return () => clearTimeout(initTimeout);
          }, []);

          // Center on first slide when presentation view becomes active
          useEffect(() => {
            const checkIfPresentationActive = () => {
              const presentationContent = document.getElementById('presentation-content');
              if (presentationContent && presentationContent.classList.contains('active')) {
                // Presentation view is now active, center on first slide if we haven't moved yet
                if (slides.length > 0 && pan.x === 0 && pan.y === 0 && zoom === 1) {
                  console.log('[Presentation] Presentation view activated, centering on first slide');
                  setTimeout(() => {
                    if (canvasRef.current && canvasRef.current.clientWidth > 0) {
                      goToSlide(0);
                    }
                  }, 150); // Slightly longer delay to ensure view is fully active
                }
              }
            };

            // Set up a mutation observer to watch for class changes on the presentation content
            const presentationContent = document.getElementById('presentation-content');
            if (presentationContent) {
              const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                  if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    checkIfPresentationActive();
                  }
                });
              });

              observer.observe(presentationContent, {
                attributes: true,
                attributeFilter: ['class']
              });

              // Also check immediately in case it's already active
              checkIfPresentationActive();

              return () => observer.disconnect();
            }
          }, [slides.length, pan.x, pan.y, zoom, goToSlide]);

          // Listen for content updates from the lecture summary generator
          useEffect(() => {
            const handleContentUpdate = (event) => {
              // Received content update event
              const newContent = event.detail?.content;
              
              if (newContent && newContent.trim()) {
                // Parsing new content into slides
                const newSlides = parseMarkdown(newContent);
                
                setSlides(newSlides);
                setCurrentSlide(0);
                setZoom(1);
                setPan({ x: 0, y: 0 });
                setFocusedSlide(null);
                
                // Center first slide after state updates
                setTimeout(() => {
                  if (canvasRef.current && newSlides.length > 0) {
                    console.log('[Presentation] Centering first slide after content update');
                    goToSlide(0);
                  }
                }, 50);
                // Successfully updated slides
              } else {
                console.warn('[React Presentation] No valid content received');
              }
            };

            // Setting up content update listener
            window.addEventListener('updatePresentationContent', handleContentUpdate);
            return () => {
              // Removing content update listener
              window.removeEventListener('updatePresentationContent', handleContentUpdate);
            };
          }, []);

          // Set up Electron API listeners (only once)
          useEffect(() => {
            if (isElectron && window.electronAPI) {
              // File loading
              window.electronAPI.loadPresentationFile((content, filePath, error) => {
                if (error) {
                  console.error('Error loading file:', error);
                  return;
                }
                if (content) {
                  const newSlides = parseMarkdown(content);
                  setSlides(newSlides);
                  setCurrentSlide(0);
                  // Ensure canvas is ready before centering first slide
                  setTimeout(() => {
                    if (canvasRef.current && newSlides.length > 0) {
                      console.log('[Presentation] Centering first slide on presentation start');
                      goToSlide(0);
                    }
                  }, 100); // Give more time for canvas to be ready
                }
              });

              // Presentation controls
              window.electronAPI.onStartPresentation(() => {
                setIsPresenting(true);
              });

              window.electronAPI.onExitPresentation(() => {
                setIsPresenting(false);
              });

              window.electronAPI.onTogglePresentationMode(() => {
                // Switch to presentation mode
                switchToMode('presentation');
              });

              // Zoom controls
              window.electronAPI.onZoomIn(() => {
                handleZoomIn();
              });

              window.electronAPI.onZoomOut(() => {
                handleZoomOut();
              });

              window.electronAPI.onResetZoom(() => {
                resetView();
              });

              // Layout changes
              window.electronAPI.onChangeLayout((layout) => {
                setLayoutType(layout);
              });
            }

            return () => {
              if (isElectron && window.electronAPI) {
                window.electronAPI.removeAllListeners();
              }
            };
          }, []);

          // Set up navigation listeners that depend on current state
          useEffect(() => {
            if (isElectron && window.electronAPI) {
              window.electronAPI.onNextSlide(() => {
                goToSlide(currentSlide + 1);
              });

              window.electronAPI.onPreviousSlide(() => {
                goToSlide(currentSlide - 1);
              });

              window.electronAPI.onFirstSlide(() => {
                goToSlide(0);
              });
            }
          }, [currentSlide]);

          // Recalculate positions when layout changes
          useEffect(() => {
            if (slides.length > 0) {
              const updatedSlides = slides.map((slide, index) => ({
                ...slide,
                position: calculateSlidePosition(index, slides.length)
              }));
              setSlides(updatedSlides);
            }
          }, [layoutType]);

          // Center view on first slide when slides are initially loaded
          useEffect(() => {
            if (slides.length > 0 && canvasRef.current) {
              // Only center if we're at the initial position (haven't moved around yet)
              if (pan.x === 0 && pan.y === 0 && zoom === 1 && currentSlide === 0) {
                console.log('[Presentation] Initial slides loaded, centering on first slide');
                // Small delay to ensure canvas is properly rendered
                setTimeout(() => {
                  if (canvasRef.current && canvasRef.current.clientWidth > 0) {
                    goToSlide(0);
                  }
                }, 100);
              }
            }
          }, [slides.length, pan.x, pan.y, zoom, currentSlide, goToSlide]);

          // Render math in slides whenever slides change
          useEffect(() => {
            if (slides.length > 0 && window.MathJax && window.MathJax.typesetPromise) {
              // Small delay to ensure slides are rendered in DOM
              const timer = setTimeout(() => {
                const presentationContainer = document.getElementById('presentation-content');
                if (presentationContainer) {
                  window.MathJax.typesetPromise([presentationContainer])
                    .catch((err) => console.error('Error rendering math in presentation:', err));
                }
              }, 100);
              
              return () => clearTimeout(timer);
            }
          }, [slides]);


          // Navigate to specific slide with smooth transition
          const goToSlide = useCallback((slideIndex) => {
            if (slideIndex < 0 || slideIndex >= slides.length) return;
            
            const slide = slides[slideIndex];
            const canvas = canvasRef.current;
            if (!canvas) {
              console.warn('[Presentation] Canvas not ready for goToSlide, retrying...');
              setTimeout(() => goToSlide(slideIndex), 50);
              return;
            }

            // Ensure canvas has proper dimensions
            if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
              console.warn('[Presentation] Canvas dimensions not ready, retrying...');
              setTimeout(() => goToSlide(slideIndex), 50);
              return;
            }

            const targetZoom = 1.2;
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            const slideCenterX = slide.position.x;
            const slideCenterY = slide.position.y;
            
            const targetPan = {
              x: viewportCenterX - (slideCenterX * targetZoom),
              y: viewportCenterY - (slideCenterY * targetZoom)
            };

            console.log('[Presentation] Centering slide', slideIndex, 'at position:', targetPan);
            
            setCurrentSlide(slideIndex);
            setFocusedSlide(null);
            setZoom(targetZoom);
            setPan(targetPan);
          }, [slides]);

          // Handle double click on slide to zoom in and focus
          const handleSlideDoubleClick = (slideIndex) => {
            const slide = slides[slideIndex];
            const canvas = canvasRef.current;
            if (!canvas) return;

            const targetZoom = 2;
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            const slideCenterX = slide.position.x;
            const slideCenterY = slide.position.y;
            
            const targetPan = {
              x: viewportCenterX - (slideCenterX * targetZoom),
              y: viewportCenterY - (slideCenterY * targetZoom)
            };

            setCurrentSlide(slideIndex);
            setFocusedSlide(slideIndex);
            setZoom(targetZoom);
            setPan(targetPan);
          };

          // Zoom handlers - zoom from current slide center
          const handleZoomIn = () => {
            const newZoom = Math.min(3, zoom * 1.2);
            zoomFromCurrentSlide(newZoom);
          };

          const handleZoomOut = () => {
            const newZoom = Math.max(0.1, zoom * 0.8);
            zoomFromCurrentSlide(newZoom);
          };

          // Helper function to zoom from current slide center
          const zoomFromCurrentSlide = (newZoom) => {
            if (slides.length === 0 || currentSlide >= slides.length) {
              setZoom(newZoom);
              return;
            }

            const canvas = canvasRef.current;
            if (!canvas) {
              setZoom(newZoom);
              return;
            }

            const slide = slides[currentSlide];
            const viewportCenterX = canvas.clientWidth / 2;
            const viewportCenterY = canvas.clientHeight / 2;
            
            // Calculate the current slide's position on screen
            const currentSlideCenterX = slide.position.x * zoom + pan.x;
            const currentSlideCenterY = slide.position.y * zoom + pan.y;
            
            // Calculate new pan to keep slide centered at new zoom level
            const newPan = {
              x: viewportCenterX - (slide.position.x * newZoom),
              y: viewportCenterY - (slide.position.y * newZoom)
            };

            setZoom(newZoom);
            setPan(newPan);
          };

          const resetView = () => {
            setZoom(1);
            setPan({ x: 0, y: 0 });
            setFocusedSlide(null);
          };

          // Wheel zoom effect
          useEffect(() => {
            const handleWheel = (e) => {
              e.preventDefault();
              const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
              const newZoom = Math.max(0.1, Math.min(3, zoom * zoomFactor));
              setZoom(newZoom);
            };

            const container = containerRef.current;
            if (container) {
              container.addEventListener('wheel', handleWheel, { passive: false });
              return () => container.removeEventListener('wheel', handleWheel);
            }
          }, [zoom]);

          // Keyboard navigation
          useEffect(() => {
            const handleKeyPress = (e) => {
              // Only handle keyboard events if we're in presentation view and not focused on an input element
              const presentationContent = document.getElementById('presentation-content');
              const isInPresentationView = presentationContent && presentationContent.classList.contains('active');
              const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
              
              if (!isInPresentationView || isInputFocused) {
                return; // Don't handle keyboard events if not in presentation view or if an input is focused
              }
              
              if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                goToSlide(currentSlide + 1);
              } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                goToSlide(currentSlide - 1);
              } else if (e.key === 'Home') {
                e.preventDefault();
                goToSlide(0);
              } else if (e.key === 'Escape') {
                setIsPresenting(false);
              }
            };

            window.addEventListener('keydown', handleKeyPress);
            return () => window.removeEventListener('keydown', handleKeyPress);
          }, [currentSlide, goToSlide]);

          // Control body class for presenting mode
          useEffect(() => {
            if (isPresenting) {
              document.body.classList.add('is-presenting');
              console.log('[Presentation] Added is-presenting class to body');
            } else {
              document.body.classList.remove('is-presenting');
              console.log('[Presentation] Removed is-presenting class from body');
            }
          }, [isPresenting]);

          // Listen for external exit presentation events
          useEffect(() => {
            const handleExitPresenting = () => {
              setIsPresenting(false);
            };
            
            window.addEventListener('exitPresenting', handleExitPresenting);
            return () => window.removeEventListener('exitPresenting', handleExitPresenting);
          }, []);

          // Update speaker notes display when current slide changes
          useEffect(() => {
            const updateSpeakerNotes = () => {
              const notesPanel = document.getElementById('speaker-notes-panel');
              const notesContent = document.getElementById('current-slide-notes');
              
              // Updating speaker notes
              
              if (notesPanel && notesContent && slides.length > 0 && slides[currentSlide]) {
                const currentSlideData = slides[currentSlide];
                // Getting slide speaker notes
                
                if (currentSlideData.speakerNotes && currentSlideData.speakerNotes.trim()) {
                  // Show panel when there are notes
                  notesPanel.style.display = speakerNotesVisible ? 'block' : 'none';
                  
                  // Format the speaker notes with line breaks
                  const formattedNotes = currentSlideData.speakerNotes
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line)
                    .map(line => `<p style="margin-bottom: 8px;">${line}</p>`)
                    .join('');
                  
                  // Formatted speaker notes
                  notesContent.innerHTML = formattedNotes || '<em>No speaker notes for this slide.</em>';
                } else {
                  // No notes for this slide, but keep panel visible
                  // No speaker notes found
                  notesPanel.style.display = speakerNotesVisible ? 'block' : 'none';
                  notesContent.innerHTML = '<em>No speaker notes for this slide.</em>';
                }
              } else {
                console.log('[React Presentation] Speaker notes update conditions not met:', {
                  notesPanel: !!notesPanel,
                  notesContent: !!notesContent,
                  slidesLength: slides.length,
                  currentSlide: currentSlide,
                  slideExists: !!(slides.length > 0 && slides[currentSlide])
                });
              }
            };

            updateSpeakerNotes();
          }, [currentSlide, slides, speakerNotesVisible]);

          // Initialize speaker notes panel toggle
          useEffect(() => {
            const toggleButton = document.getElementById('toggle-speaker-notes-panel');
            const notesPanel = document.getElementById('speaker-notes-panel');
            
            if (toggleButton && notesPanel) {
              const handleToggle = () => {
                const newVisibility = !speakerNotesVisible;
                setSpeakerNotesVisible(newVisibility);
                notesPanel.style.display = newVisibility ? 'block' : 'none';
                toggleButton.textContent = newVisibility ? 'Hide' : 'Show';
                
                // Remember if user manually hid the panel
                if (!newVisibility) {
                  localStorage.setItem('speakerNotesAutoHidden', 'true');
                } else {
                  localStorage.removeItem('speakerNotesAutoHidden');
                }
              };
              
              toggleButton.addEventListener('click', handleToggle);
              
              // Also add keyboard shortcut for toggling notes (N key)
              const handleKeyToggle = (e) => {
                if (e.key === 'n' || e.key === 'N') {
                  const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
                  if (!isInputFocused) {
                    e.preventDefault();
                    handleToggle();
                  }
                }
              };
              
              window.addEventListener('keydown', handleKeyToggle);
              
              return () => {
                toggleButton.removeEventListener('click', handleToggle);
                window.removeEventListener('keydown', handleKeyToggle);
              };
            }
          }, [speakerNotesVisible]);

          // Mouse handlers for panning
          const handleMouseDown = (e) => {
            // Allow panning from anywhere in the canvas, even during presentation
            setIsDragging(true);
            setDragStart({ x: e.clientX, y: e.clientY });
            setPanStart(pan);
          };

          const handleMouseMove = (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            setPan({
              x: panStart.x + deltaX,
              y: panStart.y + deltaY
            });
          };

          const handleMouseUp = () => {
            setIsDragging(false);
          };

          return (
            <div 
              ref={containerRef}
              className="w-full h-screen relative overflow-hidden cursor-grab active:cursor-grabbing" 
              style={{background: 'linear-gradient(135deg, #14532d 0%, #15803d 50%, #22c55e 100%)'}}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
            >
              {/* Controls */}
              {!isPresenting && (
                <div className="absolute top-4 left-4 z-10 flex gap-2">
                  <select
                    value={layoutType}
                    onChange={(e) => setLayoutType(e.target.value)}
                    className="px-3 py-2 text-gray-900 rounded-lg border border-gray-300 focus:border-green-500 outline-none shadow-lg"
                    style={{backgroundColor: '#fefdfb'}}
                  >
                    <option value="spiral">Spiral</option>
                    <option value="linear">Linear</option>
                    <option value="grid">Grid</option>
                    <option value="circle">Circle</option>
                    <option value="tree">Tree</option>
                    <option value="zigzag">Zigzag</option>
                  </select>
                  
                </div>
              )}

              {/* Zoom Controls */}
              {!isPresenting && (
                <div className="absolute top-4 right-4 z-10 flex gap-2">
                  <button
                    onClick={handleZoomIn}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <ZoomIn />
                  </button>
                  <button
                    onClick={handleZoomOut}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <ZoomOut />
                  </button>
                  <button
                    onClick={resetView}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    <Home />
                  </button>
                  <button
                    onClick={() => setIsPresenting(true)}
                    className="flex items-center gap-2 px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors shadow-lg border border-green-700 text-white"
                  >
                    <Play />
                    Present
                  </button>
                </div>
              )}

              {/* Navigation Controls */}
              <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-4">
                <button
                  onClick={() => goToSlide(currentSlide - 1)}
                  disabled={currentSlide === 0}
                  className="p-3 bg-cream hover:bg-gray-100 disabled:bg-gray-300 disabled:opacity-50 rounded-full transition-colors shadow-lg border text-gray-900"
                >
                  <ChevronLeft />
                </button>
                
                <div className="flex items-center gap-2 px-4 py-2 bg-cream rounded-lg shadow-lg border text-gray-900">
                  <span className="text-sm">
                    {currentSlide + 1} / {slides.length}
                  </span>
                  {slides.length > 0 && (
                    <div className="flex gap-1 ml-2">
                      {slides.map((_, index) => (
                        <button
                          key={index}
                          onClick={() => goToSlide(index)}
                          className={`w-2 h-2 rounded-full transition-colors ${
                            index === currentSlide ? 'bg-green-500' : 'bg-gray-400'
                          }`}
                        />
                      ))}
                    </div>
                  )}
                </div>

                <button
                  onClick={() => goToSlide(currentSlide + 1)}
                  disabled={currentSlide === slides.length - 1}
                  className="p-3 bg-cream hover:bg-gray-100 disabled:bg-gray-300 disabled:opacity-50 rounded-full transition-colors shadow-lg border text-gray-900"
                >
                  <ChevronRight />
                </button>
              </div>

              {/* Presentation Mode Controls */}
              {isPresenting && (
                <div className="absolute top-4 right-4 z-10 flex gap-2">
                  <button
                    onClick={handleZoomIn}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Zoom In"
                  >
                    <ZoomIn />
                  </button>
                  <button
                    onClick={handleZoomOut}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Zoom Out"
                  >
                    <ZoomOut />
                  </button>
                  <button
                    onClick={resetView}
                    className="p-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                    title="Reset Zoom"
                  >
                    <Home />
                  </button>
                  <button
                    onClick={() => setIsPresenting(false)}
                    className="px-4 py-2 bg-cream hover:bg-gray-100 rounded-lg transition-colors shadow-lg border text-gray-900"
                  >
                    Exit Presentation
                  </button>
                </div>
              )}

              {/* Canvas */}
              <div
                ref={canvasRef}
                className="w-full h-full"
                style={{
                  transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                  transformOrigin: 'center center',
                  transition: isDragging ? 'none' : 'transform 0.3s ease-out'
                }}
              >
                <div className="relative w-full h-full flex items-center justify-center">
                  {/* Slides */}
                  {slides.map((slide, index) => {
                    const isFocused = index === focusedSlide;
                    const isCurrent = index === currentSlide;
                    
                    return (
                      <div
                        key={slide.id}
                        className={`absolute bg-cream text-gray-900 rounded-xl shadow-2xl transition-all duration-300 cursor-pointer ${
                          isFocused 
                            ? 'ring-4 ring-purple-500 shadow-purple-500/50' 
                            : isCurrent 
                              ? 'ring-4 ring-green-500' 
                              : 'hover:shadow-3xl hover:scale-105'
                        }`}
                        style={{
                          left: `${slide.position.x}px`,
                          top: `${slide.position.y}px`,
                          width: '600px',
                          minHeight: '400px',
                          transform: 'translate(-50%, -50%)',
                          opacity: isPresenting && index !== currentSlide ? 0.1 : 1,
                          zIndex: isFocused ? 1000 : isCurrent ? 999 : isPresenting && index !== currentSlide ? 0 : 1,
                          position: 'absolute'
                        }}
                        onDoubleClick={() => handleSlideDoubleClick(index)}
                      >
                        <div className="p-8 h-full">
                            <div 
                            className="slide-content"
                            dangerouslySetInnerHTML={{ __html: slide.parsed }}
                          />
                        </div>
                      </div>
                    );
                  })}

                  {/* Connection Lines */}
                  <svg className="absolute inset-0 pointer-events-none" style={{ width: '200%', height: '200%' }}>
                    {slides.map((slide, index) => {
                      if (index === slides.length - 1) return null;
                      const nextSlide = slides[index + 1];
                      return (
                        <line
                          key={`line-${index}`}
                          x1={slide.position.x + 300}
                          y1={slide.position.y + 200}
                          x2={nextSlide.position.x + 300}
                          y2={nextSlide.position.y + 200}
                          stroke="rgba(255,255,255,0.1)"
                          strokeWidth="2"
                          strokeDasharray="5,5"
                        />
                      );
                    })}
                  </svg>
                </div>
              </div>
            </div>
          );
        };

        // Global content switching functions
        let currentMode = 'editor';
        let presentationEditorContent = '';

        // Speaker Notes Functions
        function extractSpeakerNotes(content) {
          if (!content) return [];
          
          // Split content by slide markers
          const slides = content.split(/\n---\n|\n--- \n/);
          const speakerNotes = [];
          
          slides.forEach((slide, index) => {
            // Extract notes using regex
            const notesRegex = /```notes\s*\n([\s\S]*?)\n```/g;
            const slideNotes = [];
            let match;
            
            while ((match = notesRegex.exec(slide)) !== null) {
              slideNotes.push(match[1].trim());
            }
            
            speakerNotes.push(slideNotes.join('\n\n'));
          });
          
          return speakerNotes;
        }
        
        function showSpeakerNotesPanel(content) {
          const panel = document.getElementById('speaker-notes-panel');
          const notesContainer = document.getElementById('current-slide-notes');
          
          if (panel && notesContainer) {
            panel.style.display = 'block';
            
            // Add exit presentation mode button if not already present and actively presenting
            if (!document.getElementById('exit-presentation-btn') && document.body.classList.contains('is-presenting')) {
              const exitBtn = document.createElement('button');
              exitBtn.id = 'exit-presentation-btn';
              exitBtn.innerHTML = 'Exit Presentation (ESC)';
              exitBtn.style.cssText = 'position: fixed; top: 10px; right: 10px; z-index: 10000; padding: 8px 16px; background: rgba(0,0,0,0.7); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-size: 12px;';
              exitBtn.onclick = () => {
                // Trigger the React component to exit presenting
                const event = new CustomEvent('exitPresenting');
                window.dispatchEvent(event);
              };
              document.body.appendChild(exitBtn);
            }
            
            // Extract all speaker notes
            const allNotes = extractSpeakerNotes(content);
            const currentSlideNotes = allNotes[0] || ''; // Start with first slide
            
            if (currentSlideNotes) {
              notesContainer.innerHTML = currentSlideNotes.replace(/\n/g, '<br>');
            } else {
              notesContainer.innerHTML = '<em>No speaker notes for this slide.</em>';
            }
            
            console.log('[Speaker Notes] Panel shown with notes:', currentSlideNotes);
          }
        }
        
        function hideSpeakerNotesPanel() {
          const panel = document.getElementById('speaker-notes-panel');
          if (panel) {
            panel.style.display = 'none';
            console.log('[Speaker Notes] Panel hidden');
          }
          
          // Remove exit presentation button
          const exitBtn = document.getElementById('exit-presentation-btn');
          if (exitBtn) {
            exitBtn.remove();
          }
        }
        
        function restoreUIElementsAfterPresentation() {
          console.log('[Mode Switching] Restoring UI elements after presentation mode');
          
          // Force refresh of pane visibility and layout
          if (window.refreshPaneVisibility) {
            window.refreshPaneVisibility();
          }
          
          // Reset any inline styles that might have been applied
          const elementsToReset = [
            '#left-sidebar', '#sidebar-resizer', '#editor-container', '#mode-switcher', 
            '#editor-toolbar', '#right-pane', '#main-content'
          ];
          
          elementsToReset.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
              // Remove any inline display styles that might override CSS
              element.style.removeProperty('display');
              element.style.removeProperty('width');
              element.style.removeProperty('height');
              element.style.removeProperty('flex');
            }
          });
          
          // Trigger a layout refresh
          setTimeout(() => {
            if (window.refreshEditorLayout) {
              window.refreshEditorLayout();
            }
            
            // Ensure editor is visible and focused
            const editorContainer = document.getElementById('editor-container');
            if (editorContainer) {
              editorContainer.style.display = '';
            }
            
            console.log('[Mode Switching] UI restoration completed');
          }, 100);
        }
        
        function updateSpeakerNotes(slideIndex, content) {
          const notesContainer = document.getElementById('current-slide-notes');
          if (notesContainer) {
            const allNotes = extractSpeakerNotes(content);
            const currentSlideNotes = allNotes[slideIndex] || '';
            
            if (currentSlideNotes) {
              notesContainer.innerHTML = currentSlideNotes.replace(/\n/g, '<br>');
            } else {
              notesContainer.innerHTML = '<em>No speaker notes for this slide.</em>';
            }
            
            console.log('[Speaker Notes] Updated for slide', slideIndex, ':', currentSlideNotes);
          }
        }

        function switchToMode(modeName) {
          console.log('[Mode Switching] Switching to:', modeName);
          
          // Hide all content views
          const contentViews = document.querySelectorAll('.content-view');
          console.log('[Mode Switching] Found content views:', contentViews.length);
          contentViews.forEach(view => {
            console.log('[Mode Switching] Removing active from:', view.id);
            view.classList.remove('active');
          });

          // Show selected content view
          const targetView = document.getElementById(`${modeName}-content`);
          console.log('[Mode Switching] Target view:', targetView);
          if (targetView) {
            targetView.classList.add('active');
            console.log('[Mode Switching] Added active class to:', modeName + '-content');
            console.log('[Mode Switching] Target view classes:', targetView.className);
          } else {
            console.error('[Mode Switching] Could not find target view:', modeName + '-content');
          }

          // Update mode buttons
          const modeButtons = document.querySelectorAll('.mode-btn');
          modeButtons.forEach(btn => btn.classList.remove('active'));
          
          const targetButton = document.getElementById(`${modeName}-mode-btn`);
          if (targetButton) {
            targetButton.classList.add('active');
          }

          // Handle mode-specific logic
          if (modeName === 'presentation') {
            document.body.classList.add('presentation-mode');
            
            // Ensure React component is rendered
            const presentationRoot = document.getElementById('presentation-root');
            if (presentationRoot) {
              console.log('[Mode Switching] Rendering React presentation component for presentation mode');
              try {
                ReactDOM.render(React.createElement(MarkdownPreziApp), presentationRoot);
                console.log('[Mode Switching] React component rendered successfully');
              } catch (error) {
                console.error('[Mode Switching] Error rendering React component:', error);
              }
            }
            
            // Always get the latest content from the editor when switching to presentation mode
            console.log('[Mode Switching] Getting fresh content from editor for presentation mode');
            let currentContent = '';
            
            // Priority 1: Try getCurrentEditorContent function (from renderer.js)
            if (typeof getCurrentEditorContent === 'function') {
              try {
                currentContent = getCurrentEditorContent();
                console.log('[Mode Switching] Retrieved fresh content from getCurrentEditorContent(), length:', currentContent.length);
              } catch (error) {
                console.warn('[Mode Switching] Error calling getCurrentEditorContent():', error);
              }
            }
            
            // Priority 2: Try getting content directly from editor global variable
            if (!currentContent && window.editor && typeof window.editor.getValue === 'function') {
              try {
                currentContent = window.editor.getValue();
                console.log('[Mode Switching] Retrieved content directly from window.editor, length:', currentContent.length);
              } catch (error) {
                console.warn('[Mode Switching] Error getting content from window.editor:', error);
              }
            }
            
            // Priority 3: Try getting content from the global editor variable (without window prefix)
            if (!currentContent && typeof editor !== 'undefined' && editor && typeof editor.getValue === 'function') {
              try {
                currentContent = editor.getValue();
                console.log('[Mode Switching] Retrieved content from global editor variable, length:', currentContent.length);
              } catch (error) {
                console.warn('[Mode Switching] Error getting content from global editor:', error);
              }
            }
            
            // Fallback 1: Use pending content (from Generate Summary) if no editor content
            if (!currentContent && window.pendingPresentationContent) {
              currentContent = window.pendingPresentationContent;
              console.log('[Mode Switching] No editor content available, using pending presentation content, length:', currentContent.length);
            }
            
            // Fallback 2: Use stored content as last resort
            if (!currentContent && presentationEditorContent) {
              currentContent = presentationEditorContent;
              console.log('[Mode Switching] Using last resort stored presentation content, length:', currentContent.length);
            }
            
            // Sync the content to presentation
            if (currentContent) {
              console.log('[Mode Switching] Syncing fresh content to presentation');
              
              // Always try both methods to ensure content gets to the React component
              if (window.syncContentToPresentation) {
                window.syncContentToPresentation(currentContent);
              }
              
              // Also dispatch the event directly
              console.log('[Mode Switching] Dispatching content update event directly');
              const contentUpdateEvent = new CustomEvent('updatePresentationContent', {
                detail: { content: currentContent }
              });
              window.dispatchEvent(contentUpdateEvent);
              
              // Also set it directly for immediate access
              window.pendingPresentationContent = currentContent;
              
              // Show speaker notes panel and populate with notes
              showSpeakerNotesPanel(currentContent);
            } else {
              console.warn('[Mode Switching] No content available to sync to presentation');
              showSpeakerNotesPanel('');
            }
          } else if (modeName === 'network') {
            document.body.classList.remove('presentation-mode');
            hideSpeakerNotesPanel();
            
            // Initialize network visualization
            console.log('[Mode Switching] Initializing network visualization');
            if (window.initializeNetworkVisualization) {
              window.initializeNetworkVisualization();
            }
          } else if (modeName === 'graph') {
            document.body.classList.remove('presentation-mode');
            hideSpeakerNotesPanel();
            
            // Initialize graph visualization
            console.log('[Mode Switching] Initializing graph visualization');
            const graphContainer = document.getElementById('graph-visualization');
            if (graphContainer && window.GraphView) {
              if (!window.graphViewInstance) {
                window.graphViewInstance = new window.GraphView();
              }
              window.graphViewInstance.initialize(graphContainer);
            } else {
              console.error('[Mode Switching] GraphView not available or container not found');
            }
          } else if (modeName === 'circle') {
            document.body.classList.remove('presentation-mode');
            hideSpeakerNotesPanel();
            
            // Initialize circle visualization
            console.log('[Mode Switching] Initializing circle visualization');
            const circleContainer = document.getElementById('circle-visualization');
            if (circleContainer && window.CircleView) {
              if (!window.circleViewInstance) {
                window.circleViewInstance = new window.CircleView();
              }
              window.circleViewInstance.initialize(circleContainer);
            } else {
              console.log('[Mode Switching] CircleView not yet available - showing placeholder');
              // Show placeholder until you add the CircleView module
            }
          } else {
            document.body.classList.remove('presentation-mode');
            hideSpeakerNotesPanel();
            
            // Don't restore UI elements automatically - only when actually exiting presenting mode
            // The is-presenting class controls the UI visibility now
          }

          currentMode = modeName;
        }

        // Set up mode switching
        function setupSpeakerNotesResize() {
          const panel = document.getElementById('speaker-notes-panel');
          const resizeHandle = document.getElementById('speaker-notes-resize-handle');
          const presentationContent = document.getElementById('presentation-content');
          
          if (!panel || !resizeHandle || !presentationContent) return;
          
          let isResizing = false;
          let startY = 0;
          let startHeight = 0;
          
          // Mouse down on resize handle
          resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startY = e.clientY;
            startHeight = panel.offsetHeight;
            
            // Prevent text selection during drag
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'ns-resize';
            
            console.log('[Speaker Notes] Started resizing, startY:', startY, 'startHeight:', startHeight);
            e.preventDefault();
          });
          
          // Mouse move for resizing
          document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const deltaY = startY - e.clientY; // Inverted because panel grows upward
            const newHeight = Math.max(80, Math.min(startHeight + deltaY, presentationContent.offsetHeight * 0.6));
            
            panel.style.height = newHeight + 'px';
            console.log('[Speaker Notes] Resizing, deltaY:', deltaY, 'newHeight:', newHeight);
          });
          
          // Mouse up to stop resizing
          document.addEventListener('mouseup', () => {
            if (isResizing) {
              isResizing = false;
              document.body.style.userSelect = '';
              document.body.style.cursor = '';
              console.log('[Speaker Notes] Finished resizing');
            }
          });
          
          // Touch events for mobile support
          resizeHandle.addEventListener('touchstart', (e) => {
            isResizing = true;
            startY = e.touches[0].clientY;
            startHeight = panel.offsetHeight;
            e.preventDefault();
          });
          
          document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            
            const deltaY = startY - e.touches[0].clientY;
            const newHeight = Math.max(80, Math.min(startHeight + deltaY, presentationContent.offsetHeight * 0.6));
            
            panel.style.height = newHeight + 'px';
            e.preventDefault();
          });
          
          document.addEventListener('touchend', () => {
            if (isResizing) {
              isResizing = false;
            }
          });
        }

        function setupModeSwitching() {
          console.log('[Mode Switching] Setting up mode switching...');

          // Set up mode button event listeners
          const editorModeBtn = document.getElementById('editor-mode-btn');
          const presentationModeBtn = document.getElementById('presentation-mode-btn');
          const networkModeBtn = document.getElementById('network-mode-btn');

          if (editorModeBtn) {
            editorModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Editor mode button clicked');
              switchToMode('editor');
            });
          }

          if (presentationModeBtn) {
            presentationModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Presentation mode button clicked');
              switchToMode('presentation');
            });
          }

          if (networkModeBtn) {
            networkModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Network mode button clicked');
              switchToMode('network');
            });
          }

          const graphModeBtn = document.getElementById('graph-mode-btn');
          if (graphModeBtn) {
            graphModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Graph mode button clicked');
              switchToMode('graph');
            });
          }

          const circleModeBtn = document.getElementById('circle-mode-btn');
          if (circleModeBtn) {
            circleModeBtn.addEventListener('click', () => {
              console.log('[Mode Switching] Circle mode button clicked');
              switchToMode('circle');
            });
          }
          
          // Set up speaker notes toggle
          const toggleButton = document.getElementById('toggle-speaker-notes-panel');
          if (toggleButton) {
            toggleButton.addEventListener('click', () => {
              const panel = document.getElementById('speaker-notes-panel');
              if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                toggleButton.textContent = isVisible ? 'Show' : 'Hide';
                console.log('[Speaker Notes] Panel toggled:', isVisible ? 'hidden' : 'shown');
              }
            });
          }
          
          // Set up speaker notes panel resizing
          setupSpeakerNotesResize();

          // Render React presentation component
          const presentationRoot = document.getElementById('presentation-root');
          if (presentationRoot) {
            console.log('[Mode Switching] Rendering React presentation component');
            console.log('[Mode Switching] Presentation root element:', presentationRoot);
            try {
              ReactDOM.render(React.createElement(MarkdownPreziApp), presentationRoot);
              console.log('[Mode Switching] React component rendered successfully');
            } catch (error) {
              console.error('[Mode Switching] Error rendering React component:', error);
            }
          } else {
            console.error('[Mode Switching] Could not find presentation-root element');
          }

          // Store content for presentation mode
          window.pendingPresentationContent = null;
          
          // Set up content synchronization
          window.syncContentToPresentation = (content) => {
            console.log('Syncing content to presentation, content length:', content?.length);
            
            // Store the content for later use
            window.pendingPresentationContent = content;
            
            // Try to update the presentation immediately
            const contentUpdateEvent = new CustomEvent('updatePresentationContent', {
              detail: { content: content }
            });
            window.dispatchEvent(contentUpdateEvent);
            console.log('[Content Sync] Stored content and dispatched updatePresentationContent event');
          };

          // Set up IPC event listeners for lecture summary generation
          if (window.electronAPI) {
            window.electronAPI.onLoadPresentationContent((content) => {
              console.log('[IPC] Received presentation content to load');
              window.syncContentToPresentation(content);
            });

            window.electronAPI.onSwitchToPresentation(() => {
              console.log('[IPC] Switching to presentation mode');
              switchToMode('presentation');
            });

            window.electronAPI.onSwitchToEditor(() => {
              console.log('[IPC] Switching to editor mode');
              switchToMode('editor');
            });

            window.electronAPI.onSwitchToNetwork(() => {
              console.log('[IPC] Switching to network mode');
              switchToMode('network');
            });

            // Style settings handler
            window.electronAPI.on('open-style-settings', () => {
              console.log('[IPC] Opening style settings');
              if (window.styleSettingsUI) {
                window.styleSettingsUI.showStyleSettings();
              }
            });

            window.electronAPI.onFormatText((data) => {
              console.log('[IPC] Format text received:', data);
              console.log('[IPC] Format type:', data?.type);
              if (data && data.type) {
                handleFormatText(data.type);
              } else {
                console.error('[IPC] Format text: Invalid data received:', data);
              }
            });
          }

          // Set up title bar controls (only in Electron)
          if (window.electronAPI && window.electronAPI.isElectron) {
            const minimizeBtn = document.getElementById('minimize-btn');
            const maximizeBtn = document.getElementById('maximize-btn');
            const closeBtn = document.getElementById('close-btn');

            if (minimizeBtn) {
              minimizeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Minimize clicked');
                // Add minimize functionality if needed
              });
            }

            if (maximizeBtn) {
              maximizeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Maximize clicked');
                // Add maximize functionality if needed
              });
            }

            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                console.log('[Title Bar] Close clicked');
                if (window.electronAPI.closeWindow) {
                  window.electronAPI.closeWindow();
                } else {
                  window.close();
                }
              });
            }
          } else {
            // Hide title bar controls on web
            const titleBarControls = document.querySelector('.title-bar-controls');
            if (titleBarControls) {
              titleBarControls.style.display = 'none';
            }
          }

          // Hide custom controls on macOS since native ones are invisible but functional
          if (window.electronAPI && window.electronAPI.platform === 'darwin') {
            const titleBarControls = document.querySelector('.title-bar-controls');
            if (titleBarControls) {
              titleBarControls.style.display = 'none';
            }
          }
        }

        // Try setup immediately and on DOMContentLoaded
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setupModeSwitching);
        } else {
          setupModeSwitching();
        }

        // Global keyboard shortcuts for presentation mode
        document.addEventListener('keydown', (e) => {
          // ESC to exit presenting mode (not just presentation mode)
          if (e.key === 'Escape' && document.body.classList.contains('is-presenting')) {
            e.preventDefault();
            // This will be handled by the React component's useEffect for ESC key
            // The React component should handle setIsPresenting(false)
          }
          
          // Cmd+Shift+' to invoke Ash (AI Writing Companion)
          if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === "'") {
            e.preventDefault();
            console.log('[Keyboard] Ash shortcut pressed - checking availability:', {
              hasAICompanion: !!window.aiCompanion,
              hasHandleKeyboardInvocation: typeof window.aiCompanion?.handleKeyboardInvocation === 'function',
              hasGamification: !!window.gamification,
              hasGamificationManager: !!window.gamificationManager
            });
            if (window.aiCompanion && typeof window.aiCompanion.handleKeyboardInvocation === 'function') {
              console.log('[Keyboard] Invoking Ash via Cmd+Shift+\'');
              window.aiCompanion.handleKeyboardInvocation();
            } else {
              console.warn('[Keyboard] AI Companion not available for keyboard shortcut');
              console.log('[Keyboard] Available objects:', {
                aiCompanion: window.aiCompanion,
                gamification: window.gamification,
                gamificationManager: window.gamificationManager
              });
              
              // Try to force initialize AI companion
              if (window.gamification && typeof window.gamification.initializeAICompanion === 'function') {
                console.log('[Keyboard] Attempting to force initialize AI Companion');
                window.gamification.initializeAICompanion();
                
                // Try again after a brief delay
                setTimeout(() => {
                  if (window.aiCompanion && typeof window.aiCompanion.handleKeyboardInvocation === 'function') {
                    console.log('[Keyboard] AI Companion now available, invoking Ash');
                    window.aiCompanion.handleKeyboardInvocation();
                  } else {
                    alert('AI Companion could not be initialized. Please check the console for errors.');
                  }
                }, 100);
              }
            }
          }
          
          // F5 or Ctrl/Cmd+P to toggle presentation mode (not presenting)
          if ((e.key === 'F5' || (e.key === 'p' && (e.ctrlKey || e.metaKey))) && !e.altKey && !e.shiftKey) {
            e.preventDefault();
            const isInPresentationMode = document.body.classList.contains('presentation-mode');
            switchMode(isInPresentationMode ? 'editor' : 'presentation');
          }
        });

        // Expose mode switching globally
        window.switchToMode = switchToMode;
        window.updateSpeakerNotes = updateSpeakerNotes;
        
        // Global function to force show toggle buttons (debugging)
        window.forceShowToggleButtons = function() {
            console.log('[DEBUG] Forcing right pane toggle buttons to show...');
            const toggleButtons = document.querySelector('#right-pane .toggle-buttons');
            if (toggleButtons) {
                toggleButtons.style.display = 'flex';
                toggleButtons.style.visibility = 'visible';
                toggleButtons.style.opacity = '1';
                toggleButtons.style.position = 'relative';
                toggleButtons.style.zIndex = '1000';
                toggleButtons.style.minHeight = '50px';
                console.log('[DEBUG] Right pane toggle buttons forced visible');
                
                // Also check if parent has issues
                const parent = toggleButtons.parentElement;
                if (parent) {
                    console.log('[DEBUG] Parent element:', parent);
                    console.log('[DEBUG] Parent display:', window.getComputedStyle(parent).display);
                    console.log('[DEBUG] Parent visibility:', window.getComputedStyle(parent).visibility);
                }
            } else {
                console.log('[DEBUG] Right pane toggle buttons element not found');
            }
        };
        
        // Global function to fix stuck processing indicators
        window.fixStuckProcessingIndicator = function() {
            console.log('[Debug] Attempting to fix stuck processing indicator...');
            let fixed = false;
            
            // Method 1: Try to hide via flow detection instance
            if (window.aiFlowDetection && typeof window.aiFlowDetection.forceHideIndicator === 'function') {
                window.aiFlowDetection.forceHideIndicator();
                console.log('[Debug] Used aiFlowDetection.forceHideIndicator()');
                fixed = true;
            }
            
            // Method 2: Direct DOM manipulation to hide any visible flow indicators
            const flowIndicator = document.getElementById('ai-flow-indicator');
            if (flowIndicator && (flowIndicator.classList.contains('visible') || flowIndicator.style.display !== 'none')) {
                flowIndicator.classList.remove('visible', 'flow-deep', 'flow-light', 'flow-struggling');
                flowIndicator.style.display = 'none';
                flowIndicator.style.opacity = '0';
                console.log('[Debug] Direct DOM hide of flow indicator');
                fixed = true;
            }
            
            // Method 3: Clear all active timeouts related to indicators
            if (window.aiFlowDetection && window.aiFlowDetection.flowIndicatorTimeout) {
                clearTimeout(window.aiFlowDetection.flowIndicatorTimeout);
                window.aiFlowDetection.flowIndicatorTimeout = null;
                console.log('[Debug] Cleared flow indicator timeout');
                fixed = true;
            }
            
            // Method 4: Look for any other processing/loading indicators
            const loadingSelectors = [
                '.loading', '.processing', '.spinner', '[class*="load"]', '[class*="process"]',
                '.flow-indicator', '[class*="flow"]', '.ai-flow-indicator'
            ];
            
            loadingSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    if (el.style.display !== 'none' || el.classList.contains('visible')) {
                        el.style.display = 'none';
                        el.style.opacity = '0';
                        el.classList.remove('visible', 'active', 'show');
                        el.classList.add('hidden');
                        console.log('[Debug] Hid element with selector:', selector, el.className);
                        fixed = true;
                    }
                });
            });
            
            // Method 5: Stop any intervals that might be causing the indicator to reappear
            if (window.aiFlowDetection) {
                window.aiFlowDetection.flowEngine.isActive = false;
                console.log('[Debug] Deactivated flow engine');
                fixed = true;
            }
            
            console.log(fixed ? '[Debug] Processing indicator fix applied' : '[Debug] No stuck indicators found');
            
            console.log('[Debug] Processing indicator fix complete. Try typing to see if indicator reappears.');
        };

        // Handle formatting from menu
        function handleFormatText(type) {
          // Ensure we're in editor mode
          if (currentMode !== 'editor') {
            switchToMode('editor');
            // Small delay to ensure mode switch completes
            setTimeout(() => applyFormatting(type), 100);
          } else {
            applyFormatting(type);
          }
        }

        function applyFormatting(type) {
          // Check if formatText function is available
          if (!window.formatText) {
            console.error('[Format] formatText function not available');
            return;
          }

          switch(type) {
            case 'bold':
              window.formatText('**', '**', 'bold text');
              break;
              
            case 'italic':
              window.formatText('*', '*', 'italic text');
              break;
              
            case 'code':
              window.formatText('`', '`', 'code');
              break;
              
            case 'heading1':
              insertAtLineStart('# ', 'Heading 1');
              break;
              
            case 'heading2':
              insertAtLineStart('## ', 'Heading 2');
              break;
              
            case 'heading3':
              insertAtLineStart('### ', 'Heading 3');
              break;
              
            case 'bulletlist':
              insertAtLineStart('- ', 'List item');
              break;
              
            case 'numberedlist':
              insertAtLineStart('1. ', 'List item');
              break;
              
            case 'blockquote':
              insertAtLineStart('> ', 'Quote text');
              break;
              
            case 'link':
              window.formatText('[', '](url)', 'link text');
              break;
              
            case 'image':
              window.formatText('![', '](image-url)', 'alt text');
              break;
              
            case 'strikethrough':
              window.formatText('~~', '~~', 'strikethrough text');
              break;
              
            case 'fold-current':
              if (window.foldCurrent) {
                window.foldCurrent();
              }
              break;
              
            case 'unfold-current':
              if (window.unfoldCurrent) {
                window.unfoldCurrent();
              }
              break;
              
            case 'fold-all':
              if (window.foldAll) {
                window.foldAll();
              }
              break;
              
            case 'unfold-all':
              if (window.unfoldAll) {
                window.unfoldAll();
              }
              break;
              
            default:
              console.warn('[Format] Unknown format type:', type);
          }
        }

        function insertAtLineStart(prefix, placeholder) {
          if (!window.editor) return;
          
          const selection = window.editor.getSelection();
          const position = selection.getStartPosition();
          const line = window.editor.getModel().getLineContent(position.lineNumber);
          
          // Check if line already starts with the prefix
          if (line.trimStart().startsWith(prefix.trim())) {
            // Remove the prefix
            const newLine = line.replace(new RegExp('^(\\s*)' + prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')), '$1');
            const range = new monaco.Range(position.lineNumber, 1, position.lineNumber, line.length + 1);
            window.editor.executeEdits('format-text', [{
              range: range,
              text: newLine
            }]);
          } else {
            // Add the prefix
            const leadingWhitespace = line.match(/^(\s*)/)[1];
            const newLine = leadingWhitespace + prefix + (line.trim() || placeholder);
            const range = new monaco.Range(position.lineNumber, 1, position.lineNumber, line.length + 1);
            window.editor.executeEdits('format-text', [{
              range: range,
              text: newLine
            }]);
          }
        }

        window.handleFormatText = handleFormatText;

        // === Network Visualization ===
        let networkGraph = null;
        let networkData = { nodes: [], links: [] };

        // Parse markdown content to extract internal links
        function parseInternalLinks(content, filename) {
          const links = [];
          console.log(`[Network] Parsing links from ${filename}, content length: ${content ? content.length : 0}`);
          
          // Match [[filename]] and [[filename|display text]] patterns
          const internalLinkRegex = /\[\[([^\]|]+)(\|[^\]]+)?\]\]/g;
          let match;
          let matchCount = 0;
          
          while ((match = internalLinkRegex.exec(content)) !== null) {
            matchCount++;
            const targetFile = match[1].trim();
            // Ensure it ends with .md if it doesn't have an extension
            const targetWithExt = targetFile.includes('.') ? targetFile : targetFile + '.md';
            console.log(`[Network] Found link in ${filename}: [[${targetFile}]] -> ${targetWithExt}`);
            links.push({
              source: filename,
              target: targetWithExt,
              type: 'internal'
            });
          }
          
          if (matchCount === 0 && content && content.includes('[[')) {
            console.log(`[Network] File ${filename} contains [[ but no matches found. Sample:`, content.substring(0, 500));
          }

          // Also match standard markdown links to .md files
          const mdLinkRegex = /\[([^\]]+)\]\(([^)]+\.md)\)/g;
          while ((match = mdLinkRegex.exec(content)) !== null) {
            const targetFile = match[2];
            links.push({
              source: filename,
              target: targetFile,
              type: 'markdown'
            });
          }

          return links;
        }

        // Get file content for link parsing
        async function getFileContentForParsing(filename) {
          try {
            if (window.electronAPI && window.electronAPI.invoke) {
              const result = await window.electronAPI.invoke('read-file-content', filename);
              // The IPC handler returns an object with { success, content, filePath }
              if (result && result.success && result.content) {
                return result.content;
              } else if (result && !result.success) {
                console.warn('[Network] Failed to read file:', filename, result.error);
                return '';
              }
              // Fallback if result structure is different
              return result || '';
            }
            return '';
          } catch (error) {
            console.warn('[Network] Could not read file:', filename, error);
            return '';
          }
        }

        // Build network data from files
        async function buildNetworkData() {
          console.log('[Network] Building network data...');
          
          try {
            // Get filtered files for visualization
            const result = await window.getFilteredVisualizationFiles();
            const files = result.files;
            
            console.log(`[Network] Using ${files.length} files (filtered from ${result.totalFiles} total)`);
            console.log('[Network] Applied filters:', result.filters);
            
            // Convert to the format expected by the network code
            const mdFiles = files.map(filePath => ({
              name: filePath.split('/').pop(), // Get just the filename
              fullPath: filePath,
              isDirectory: false
            }));
            
            console.log('[Network] Prepared markdown files:', mdFiles.length);
            
            // Create nodes for each file
            const nodes = mdFiles.map(file => ({
              id: file.name,
              name: file.name.replace('.md', ''),
              type: 'file',
              size: 10
            }));

            // Parse links from each file
            const allLinks = [];
            for (const file of mdFiles) {
              try {
                const content = await getFileContentForParsing(file.name);
                console.log(`[Network] Got content for ${file.name}:`, content ? `${content.length} chars` : 'null/empty');
                if (content) {
                  const fileLinks = parseInternalLinks(content, file.name);
                  if (fileLinks.length > 0) {
                    console.log(`[Network] Found ${fileLinks.length} links in ${file.name}:`, fileLinks);
                  }
                  allLinks.push(...fileLinks);
                } else {
                  console.log(`[Network] No content retrieved for ${file.name}`);
                }
              } catch (error) {
                console.warn('[Network] Error parsing file:', file.name, error);
              }
            }

            // Filter links to only include files that exist in our nodes
            const nodeIds = new Set(nodes.map(n => n.id));
            
            // Debug: Log what we have
            console.log('[Network] All links before filtering:', allLinks);
            console.log('[Network] Node IDs:', Array.from(nodeIds));
            const links = allLinks.filter(link => {
              const sourceExists = nodeIds.has(link.source);
              const targetExists = nodeIds.has(link.target);
              if (!sourceExists || !targetExists) {
                console.log(`[Network] Filtering out link: source="${link.source}" (exists: ${sourceExists}), target="${link.target}" (exists: ${targetExists})`);
              }
              return sourceExists && targetExists;
            });

            console.log('[Network] Built network:', nodes.length, 'nodes,', links.length, 'links');
            console.log('[Network] Final links:', links);
            
            return { nodes, links };
          } catch (error) {
            console.error('[Network] Error building network data:', error);
            return { nodes: [], links: [] };
          }
        }

        // Initialize D3 network visualization
        function createNetworkVisualization(data) {
          const container = document.getElementById('network-canvas');
          if (!container) {
            console.error('[Network] Canvas container not found');
            return;
          }

          // Clear existing visualization
          d3.select(container).selectAll('*').remove();

          const width = container.offsetWidth;
          const height = container.offsetHeight;
          
          console.log('[Network] Creating visualization:', width, 'x', height);

          // Create SVG
          const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('border', '1px solid #ddd');

          // Create zoom behavior
          const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
              g.attr('transform', event.transform);
            });

          svg.call(zoom);

          // Create group for zoomable content
          const g = svg.append('g');

          // Create force simulation
          const simulation = d3.forceSimulation(data.nodes)
            .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2));

          // Create links
          const link = g.append('g')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .selectAll('line')
            .data(data.links)
            .join('line')
            .attr('stroke-width', d => d.type === 'internal' ? 2 : 1)
            .attr('stroke', d => d.type === 'internal' ? '#16a34a' : '#999');

          // Create nodes
          const node = g.append('g')
            .attr('stroke', '#fff')
            .attr('stroke-width', 1.5)
            .selectAll('circle')
            .data(data.nodes)
            .join('circle')
            .attr('r', d => 8 + (d.size || 0))
            .attr('fill', '#16a34a')
            .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended));

          // Add labels
          const label = g.append('g')
            .selectAll('text')
            .data(data.nodes)
            .join('text')
            .text(d => d.name)
            .attr('font-size', 12)
            .attr('font-family', 'Arial, sans-serif')
            .attr('fill', '#333')
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('pointer-events', 'none');

          // Add tooltips and click handlers
          node.append('title').text(d => d.id);
          
          node.on('click', (event, d) => {
            console.log('[Network] Node clicked:', d.id);
            // Open file in editor
            if (window.electronAPI && window.electronAPI.invoke) {
              window.electronAPI.invoke('perform-open-file', d.id)
                .then(() => {
                  console.log('[Network] File opened:', d.id);
                  switchToMode('editor'); // Switch back to editor to see the file
                })
                .catch(err => console.error('[Network] Error opening file:', err));
            }
          });

          // Update positions on simulation tick
          simulation.on('tick', () => {
            link
              .attr('x1', d => d.source.x)
              .attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x)
              .attr('y2', d => d.target.y);

            node
              .attr('cx', d => d.x)
              .attr('cy', d => d.y);

            label
              .attr('x', d => d.x)
              .attr('y', d => d.y);
          });

          // Drag functions
          function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
          }

          function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
          }

          function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
          }

          // Store references for controls
          networkGraph = {
            svg,
            g,
            simulation,
            zoom,
            width,
            height
          };

          // Update stats
          updateNetworkStats(data);
        }

        // Update network statistics display
        function updateNetworkStats(data) {
          const statsEl = document.getElementById('network-stats');
          if (statsEl) {
            statsEl.textContent = `Files: ${data.nodes.length} | Links: ${data.links.length}`;
          }
        }

        // Initialize network visualization
        async function initializeNetworkVisualization() {
          console.log('[Network] Initializing network visualization...');
          
          // Show loading state
          const canvas = document.getElementById('network-canvas');
          if (canvas) {
            canvas.innerHTML = `
              <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;">
                <div style="font-size: 24px; margin-bottom: 10px;">üîÑ</div>
                <div>Building network...</div>
              </div>
            `;
          }

          try {
            networkData = await buildNetworkData();
            
            if (networkData.nodes.length === 0) {
              // Show empty state
              canvas.innerHTML = `
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;">
                  <div style="font-size: 24px; margin-bottom: 10px;">üìÅ</div>
                  <div>No markdown files found</div>
                  <div style="font-size: 12px; margin-top: 5px; color: #999;">Create some .md files with internal links to see the network</div>
                </div>
              `;
              return;
            }

            createNetworkVisualization(networkData);
            
          } catch (error) {
            console.error('[Network] Error initializing visualization:', error);
            if (canvas) {
              canvas.innerHTML = `
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;">
                  <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                  <div>Error loading network</div>
                  <div style="font-size: 12px; margin-top: 5px; color: #999;">${error.message}</div>
                </div>
              `;
            }
          }
        }

        // Network control functions
        function refreshNetwork() {
          console.log('[Network] Refreshing network...');
          initializeNetworkVisualization();
        }

        function centerNetwork() {
          if (networkGraph && networkGraph.svg) {
            console.log('[Network] Centering network...');
            const transform = d3.zoomIdentity.translate(networkGraph.width / 2, networkGraph.height / 2).scale(1);
            networkGraph.svg.transition().duration(750).call(networkGraph.zoom.transform, transform);
          }
        }

        function fitNetwork() {
          if (networkGraph && networkGraph.svg && networkData.nodes.length > 0) {
            console.log('[Network] Fitting network to view...');
            
            // Calculate bounds of nodes
            let minX = d3.min(networkData.nodes, d => d.x || 0);
            let maxX = d3.max(networkData.nodes, d => d.x || 0);
            let minY = d3.min(networkData.nodes, d => d.y || 0);
            let maxY = d3.max(networkData.nodes, d => d.y || 0);
            
            const padding = 50;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            
            const scale = Math.min(networkGraph.width / width, networkGraph.height / height, 2);
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            const transform = d3.zoomIdentity
              .translate(networkGraph.width / 2, networkGraph.height / 2)
              .scale(scale)
              .translate(-centerX, -centerY);
              
            networkGraph.svg.transition().duration(750).call(networkGraph.zoom.transform, transform);
          }
        }

        // Set up network controls
        function setupNetworkControls() {
          const refreshBtn = document.getElementById('network-refresh');
          const centerBtn = document.getElementById('network-center');
          const fitBtn = document.getElementById('network-fit');
          
          if (refreshBtn) {
            refreshBtn.addEventListener('click', refreshNetwork);
          }
          if (centerBtn) {
            centerBtn.addEventListener('click', centerNetwork);
          }
          if (fitBtn) {
            fitBtn.addEventListener('click', fitNetwork);
          }
        }

        // Expose network functions globally
        window.initializeNetworkVisualization = initializeNetworkVisualization;
        window.refreshNetwork = refreshNetwork;
        
        // Update network when file changes
        function updateNetworkOnFileChange() {
          // Only refresh if we're currently in network mode and network is initialized
          if (currentMode === 'network' && networkGraph) {
            console.log('[Network] File changed, refreshing network visualization');
            setTimeout(refreshNetwork, 500); // Small delay to ensure file is saved
          }
        }
        
        // Hook into the editor change events for real-time updates
        function setupNetworkFileWatchers() {
          // Watch for file open events
          if (window.electronAPI && window.electronAPI.onFileOpened) {
            window.electronAPI.onFileOpened(updateNetworkOnFileChange);
          }
          
          // Watch for editor content changes (debounced)
          let debounceTimer = null;
          function debounceNetworkUpdate() {
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(updateNetworkOnFileChange, 2000); // 2 second delay
          }
          
          // Hook into Monaco editor changes
          if (window.editor && typeof window.editor.onDidChangeModelContent === 'function') {
            window.editor.onDidChangeModelContent(debounceNetworkUpdate);
          }
          
          // Hook into autosave events if available
          document.addEventListener('file-saved', updateNetworkOnFileChange);
        }

        // Initialize style manager
        function initializeStyleSystem() {
          console.log('[StyleSystem] Initializing style management system...');
          
          // Wait for style manager to be loaded
          if (window.styleManager) {
            window.styleManager.initialize().then(() => {
              console.log('[StyleSystem] Style manager initialized successfully');
            }).catch(error => {
              console.error('[StyleSystem] Error initializing style manager:', error);
            });
          } else {
            // Retry after a short delay
            setTimeout(initializeStyleSystem, 100);
          }
        }

        // Initialize everything when DOM is ready
        function initializeApp() {
          // Initialize style system
          initializeStyleSystem();
          
          // Initialize network controls
          setupNetworkControls();
          setupNetworkFileWatchers();
          
          // Initialize gamification system
          if (typeof GamificationManager !== 'undefined' && !window.gamification) {
            console.log('[App] Initializing Gamification Manager...');
            window.gamification = new GamificationManager();
            window.gamificationManager = window.gamification; // For compatibility
            
            // Call initialize method after a short delay to ensure DOM is ready
            setTimeout(() => {
              if (typeof window.gamification.initialize === 'function') {
                console.log('[App] Calling gamification.initialize()');
                window.gamification.initialize();
              }
            }, 100);
            
            console.log('[App] Gamification Manager initialized');
          }
          
          // Initialize Ash button
          const invokeAshBtn = document.getElementById('invoke-ash-btn');
          if (invokeAshBtn) {
            console.log('[App] Ash button found, adding click handler');
            invokeAshBtn.addEventListener('click', () => {
              console.log('[UI] Ash button clicked - checking availability:', {
                hasAICompanion: !!window.aiCompanion,
                hasHandleKeyboardInvocation: typeof window.aiCompanion?.handleKeyboardInvocation === 'function',
                hasGamification: !!window.gamification,
                hasGamificationManager: !!window.gamificationManager
              });
              if (window.aiCompanion && typeof window.aiCompanion.handleKeyboardInvocation === 'function') {
                console.log('[UI] Invoking Ash via button click');
                window.aiCompanion.handleKeyboardInvocation();
              } else {
                console.warn('[UI] AI Companion not available for button click');
                console.log('[UI] Available objects:', {
                  aiCompanion: window.aiCompanion,
                  gamification: window.gamification,
                  gamificationManager: window.gamificationManager
                });
                
                // Try to force initialize AI companion
                if (window.gamification && typeof window.gamification.initializeAICompanion === 'function') {
                  console.log('[UI] Attempting to force initialize AI Companion');
                  window.gamification.initializeAICompanion();
                  
                  // Try again after a brief delay
                  setTimeout(() => {
                    if (window.aiCompanion && typeof window.aiCompanion.handleKeyboardInvocation === 'function') {
                      console.log('[UI] AI Companion now available, invoking Ash');
                      window.aiCompanion.handleKeyboardInvocation();
                    } else {
                      alert('AI Companion could not be initialized. Please check the console for errors.');
                    }
                  }, 100);
                } else {
                  alert('AI Companion is not yet initialized. Please wait a moment and try again.');
                }
              }
            });
          } else {
            console.warn('[App] Ash button not found in DOM');
          }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
          initializeApp();
        }
    </script>
</body>
</html>